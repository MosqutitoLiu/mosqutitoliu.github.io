<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[MosquitoLiu's Blog]]></title>
  <link href="http://blog.mosquitoliu.com/atom.xml" rel="self"/>
  <link href="http://blog.mosquitoliu.com/"/>
  <updated>2014-01-21T18:20:54+08:00</updated>
  <id>http://blog.mosquitoliu.com/</id>
  <author>
    <name><![CDATA[小文]]></name>
    <email><![CDATA[freefishdss@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ARC_笔记]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/01/21/arc-note/"/>
    <updated>2014-01-21T17:53:07+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/01/21/arc-note</id>
    <content type="html"><![CDATA[<ul>
<li> dealloc

<ul>
<li>释放一些不在ARC控制下的资源。如Core Foundation对象中调用CFRelease()，对那些通过malloc()分配的内存调用free(),注销通知，停止Timer。</li>
</ul>
</li>
<li> 归零弱引用

<ul>
<li>归零弱引用指针，当他指向的对象被销毁时，系统会自动设置为nil</li>
</ul>
</li>
<li> 混合支持ARC与不支持ARC

<ul>
<li>-fno-objc-arc</li>
<li>-fobjc-arc</li>
</ul>
</li>
<li> 编译时支持ARC而文件的代码不支持ARC</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#if !__has__feature(objc_arc)</span>
</span><span class='line'><span class="c1">//这里是不支持ARC的代码</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="c1">//在这里释放</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<ul>
<li> 框架中使用ARC代码

<ul>
<li>使用宏提示</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#if ! __has__feature(objc_arc)</span>
</span><span class='line'><span class="cp">#error This file is ARC only</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li> __unsafe_unretained

<ul>
<li>当你没有指针但想要保存指向某物的引用时，可以是使用__unsafe_unretained</li>
</ul>
</li>
<li> __weak

<ul>
<li>与__unsafe_unretained修饰符非常相似。只是当指针指向的内容被销毁后，弱指针便会成为空值（nil）</li>
<li>仅支持iOS5及以上的系统</li>
<li>声明weak之后，无需在viewDidUnload中将其置为nil</li>
</ul>
</li>
<li> __auto_releasing

<ul>
<li>从方法返回一个自动释放变量时使用</li>
<li>无法用在属性上</li>
</ul>
</li>
<li> 所有权修饰符与常量修饰符不同，它是位置无关的

<ul>
<li><strong>weak NSObject *myObject;和NSObject </strong>weak *myObject;意义是一样的。因为ARC的所有权修饰符是对指针起作用的而不是指向的值。</li>
</ul>
</li>
<li> __bridge

<ul>
<li>普通的转换，它告诉ARC不要增加他的引用计数的值，也不改变所有权</li>
</ul>
</li>
<li> __bridge_retained

<ul>
<li>转换C指针类型并增加引用计数的值</li>
</ul>
</li>
<li> __bridge_transfer

<ul>
<li>将Core Foundation指针类型转换成为Object-C指针并为引用计数加一</li>
</ul>
</li>
<li> 强行忽略警告</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#pragma clang diagnostic push</span>
</span><span class='line'><span class="cp">#pragma clang diagnostic ignored “-Warc-perfprmSelector-leaks”</span>
</span><span class='line'>     <span class="p">[</span><span class="n">self</span> <span class="nl">performSelector:</span><span class="n">self</span><span class="p">.</span><span class="n">mySelector</span><span class="p">];</span>
</span><span class='line'><span class="cp">#pragma clang diagnostic pop</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li> 避免循环保留</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">__weak</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">)</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span> <span class="c1">//iOS 5+</span>
</span><span class='line'><span class="n">__unsafe_unretained</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">)</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span><span class="c1">// iOS 4+</span>
</span><span class='line'>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">myBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">returnedString</span><span class="p">){</span>
</span><span class='line'><span class="n">this</span><span class="p">.</span><span class="n">labelControl</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">returnedString</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li> CFSTR()从一个制定的字符串中创建一个CFStringRef对象。</li>
<li> @autoreleasepool{}

<ul>
<li>当一段代码加入了大量的autorelease变量时</li>
<li>如果在主线程外使用cocoa调用，例如foundation应用，或者detach一个线程，需要创建自动释放池</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新的开始]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2013/07/28/newstart/"/>
    <updated>2013-07-28T23:39:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2013/07/28/newstart</id>
    <content type="html"><![CDATA[<p>很长时间没有更新Blog。主要是因为太懒了。</p>

<p>新的开始，自己要好好的努力了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[视频循环播放]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2012/04/24/shi-pin-xun-huan-bo-fang/"/>
    <updated>2012-04-24T17:42:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2012/04/24/shi-pin-xun-huan-bo-fang</id>
    <content type="html"><![CDATA[

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>moviePlayer = [[MPMoviePlayerViewController alloc] initWithContentURL:url];
</span><span class='line'>
</span><span class='line'>moviePlayer.moviePlayer.repeatMode = MPMovieRepeatModeOne;//循环播放
</span><span class='line'>……</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2012/04/23/arc/"/>
    <updated>2012-04-23T02:49:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2012/04/23/arc</id>
    <content type="html"><![CDATA[<h1>工作原理</h1>

<p>自动计数（ARC）是一个编译期间工作的能够帮你管理内存的技术。
ARC在编译期间为每个Objective-C指针变量添加合适的retain, release, autorelease等函数，保存每个变量的生存周期控制在合理的范围内，以期实现代码上的自动内存管理。
In order for the compiler to generate correct code, ARC imposes some restrictions on the methods you can use, and on how you use toll-free bridging (see “Toll-Free Bridged Types”); ARC also introduces new lifetime qualifiers for object references and declared properties.</p>

<h1>功能</h1>

<p>ARC使得你不需要再思考何时使用retain,release,autorelease这样的函数来管理内存，它提供了自动评估内存生存期的功能，并且 在编译期间自动加入合适的管理内存的方法。编译器也会自动生成dealloc函数。</p>

<!--more-->


<h1>新规则</h1>

<ul>
<li><p>不能直接调用dealloc方法，不能重载或直接调用retain, release, retainCount,或 autorelease等方法。但可以通过@selector(retain), @selector(release)这样的形式调用。</p></li>
<li><p>用户自定义的dealloc方法，不能调用[super dealloc] ，编译器会自动帮你添加这个代码。</p></li>
<li><p>对Core Foundation-style 的对象，仍可以使用CFRetain, CFRelease等方法。</p></li>
<li><p>不能使用NSAllocateObject或NSDeallocateObject去创建对象，请使用alloc方法。</p></li>
<li><p>在c语言中的结构体中，不能再使用对象指针。请放弃C结构体，使用Objective-C的类。</p></li>
<li><p>id和void*之间没有隐式的类型转换，请使用显式类型转换。</p></li>
<li><p>不能使用NSAutoreleasePool *pool= ARC提供了@autoreleasepool语句块。</p></li>
</ul>


<h1>关于对象的生命周期</h1>

<p>设置成weak的属性，不会影响对象的生命周期，如果引用的对象已经被释放，引用会指向nil。 strong引用：设置成strong的属性，会影响对象的生命周期。</p>

<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(strong) MyClass *myObject;</span></code></pre></td></tr></table></div></figure>


<p>和</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(retain) MyClass *myObject;</span></code></pre></td></tr></table></div></figure>


<p>是等效的。</p>

<p>又例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(weak) MyClass *myObject;</span></code></pre></td></tr></table></div></figure>


<p>和</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(assign) MyClass *myObject;</span></code></pre></td></tr></table></div></figure>


<p>在多数情况下等效，但当instance被释放时，设置为weak的引用会指向nil。
可用的限定词： strong， 默认的 weak <strong>unsafe_unretained，和weak的区别是当对象被释放时，引用不指向nil。 </strong>autoreleasing，当方法的参数是id*，且希望方法返回时对象被autoreleased，可以添加<strong>autoreleasing限定词。 使用</strong>weak时要特别小心，如果weak引用的对象在此次使用之前被使用过一次，那么它一直存在，直到autoreleasepool释放它，否则就是nil。</p>

<p>例如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString __weak *string = [[NSString alloc] initWithFormat:@"First Name: %@", [self firstName]];   
</span><span class='line'>string = NSLog(@"string: %@", string); //此时string为空，因为weak类型不影响对象的生命周期，对象刚创建就释放了。</span></code></pre></td></tr></table></div></figure>


<p>其他特性： 使用strong, weak, autoreleasing限定的变量会被隐式初始化为nil。</p>

<p>例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)myMethod { NSString *name; NSLog(@"name: %@", name); //会输出null }</span></code></pre></td></tr></table></div></figure>


<p>weak与assign很像,不同在于如果指向的数据被释放了,那么这个指向nil
unsafe_unretained
相当于assign,指向的数据如果被释放,这个指向原来的地址。</p>

<h1>禁用在Xcode中的特定文件的ARC</h1>

<p>选择项目->Build Phases->Compile Sources,，给需要禁止arc的文件添加 “-fno-objc-arc”（双击该文件）编译标志(Compiler Flags)。</p>

<p>如下图</p>

<p style="text-align: center;"><a href="http://www.flickr.com/photos/mosquitoliu/6956821194/" title="Flickr 上 freefishdss 的 noarc"><img src="http://farm9.staticflickr.com/8013/6956821194_ae58ab56c6.jpg" width="500" height="117" alt="noarc"></a></p>


<h1>注意事项</h1>

<ol>
<li>不可以使用retain,retainCount,release,autorelease 用@select()这样的调用也不行.属性命名不能以new开头。</li>
<li><p>若重写一个类子类的dealloc,不应调用[super dealloc],当然也不用写什么release释放一些什么对象,只是处理一些你觉得必要处理的事情吧,比如中止一个还没有完成的网络请求.</p></li>
<li><p>不能使用NSAllocateObject和NSDeallocateObject</p></li>
<li><p>你不能在c结构中使用对象,更好的方式是使用Objective-c类来代替.</p></li>
<li><p>在id和void*之间不能隐士转换，必须指明相应转换的生命周期。</p></li>
<li><p>不能使用NSAutoreleasePool对象，ARC使用@autoreleasepool{}块代替。</p></li>
</ol>


<h1>Core Foundation 对象与Objective-c对象之间的赋值,函数调用参数相互转化时需要用到的关键字</h1>

<p>__bridge</p>

<p>简单赋值,不会影响两边对象的retain count.</p>

<p>__bridge_transfer</p>

<p>赋值后释放右边的对象</p>

<p>__bridge_retained</p>

<p>赋值后也保留不释放右边的对象</p>

<p>举例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(void)test  
</span><span class='line'>{  
</span><span class='line'>    CFStringRef coreFoundationString = CFStringCreateWithCString(CFAllocatorGetDefault(),"C String", kCFStringEncodingUTF8);    // 创建 retainCount = 1
</span><span class='line'>    id unknownObjectType = (__bridge id)coreFoundationString; // 简单赋值,不变,retainCount = 1
</span><span class='line'>    CFStringRef anotherString = (__bridge_retained CFStringRef)unknownObjectType; // 保留赋值,加一,retainCount = 2
</span><span class='line'>    NSString *objCString = (__bridge_transfer NSString *)coreFoundationString; // 释放赋值,减一,retainCount =1;由于NSString*默认strong,加一,retainCount = 2
</span><span class='line'>    NSLog(@"String = %@", objCString);
</span><span class='line'>    objCString = nil;   // 不再指向原内存,原内存减一,retainCount = 1
</span><span class='line'>    CFRelease(anotherString);   // 释放,减一,retainCount = 0
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在c型的结构中使用objective-c对象</p>

<p>使用void*代替id;或者使用__unsage_unretained 修饰objective-c对象</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[腾讯微博iOS SDK使用说明]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2012/04/20/teng-xun-wei-bo-ios-sdkshi-yong-shuo-ming/"/>
    <updated>2012-04-20T18:09:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2012/04/20/teng-xun-wei-bo-ios-sdkshi-yong-shuo-ming</id>
    <content type="html"><![CDATA[<p>腾序微博开放平台提供了两个iOS的SDK，一个是官方的，一个是第三方提供的。</p>

<p>按照官方的SDK的使用说明操作后，运行程序会报错。在程序中应该将AppDelegate.m的后缀名改成.mm。这样在模拟器中就可以运行。当真机调试的时候，需要加入CoreTelephony.framework。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存管理]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2012/04/16/nei-cun-guan-li/"/>
    <updated>2012-04-16T15:58:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2012/04/16/nei-cun-guan-li</id>
    <content type="html"><![CDATA[<p>Objective-C使用了一种叫做持有计数（Retain Count）的机制来管理内存中的对象。
在Objective-C中每个对象都对应着他们自己的持有计数（Retain Count），持有计数可以理解为一个整数计数器，当使用alloc方法创建对象的时候，持有计数会自动设置为1。当你向一个对象发送retain消息时，持有计数数值会增加。相反，当你像一个对象发送release消息时，持有计数数值会减小。当对象的持有计数变为0的时候，对象会释放自己所占用的内存。</p>

<!--more-->


<h1>一、引用计数是实例对象的内存回收唯一参考</h1>

<p>引用计数(retainCount)是Objective-C管理对象引用的唯一依据。调用实例的release方法后，此属性减一，减到为零时对象的dealloc方法被自动调用，进行内存回收操作，也就是说我们永不该手动调用对象的dealloc方法。</p>

<p>下面就是它主要操作接口：</p>

<ol>
<li><p>alloc, allocWithZone,new(带初始化)</p>

<p> 为对象分配内存，retainCount为“1”，并返回此实例</p></li>
<li><p>release</p>

<p> retainCount 减“1”，减到“0”时调用此对象的dealloc方法</p></li>
<li><p>retain</p>

<p> ratianCoutn 加“1”</p></li>
<li><p>copy、mutableCopy</p>

<p> 复制一个实例，retainCount数为“1”，返回此实例。所得到的对象是与其它上下文无关的，独立的对象</p></li>
<li><p>autorelease</p>

<p> 在当前上下文的AutoreleasePool栈顶的autoreleasePool实例添加此对象，由于它的引入使Objective-C由全手动内存管理上升到半自动化。</p></li>
</ol>


<h1>二、Object-C内存管理准则</h1>

<p>我们可以把上面的接口按对retainCount的操作性质归为两类</p>

<p>Ａ类是加一操作：1，3，4
Ｂ类是减一操作：2，5（延时释放）内存管理准则如下：
1. A与Ｂ类的调用次数保持一制
2. 为了很好的保障准则一，以实例对象为单位，谁A了就谁Ｂ，没有第二者参与例：</p>

<pre><code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
    NSObject *o = [[NSObject alloc] init];    //retainCount为1
    /[o retain];    //retainCount为2
    //[o release]; //retainCount为1
    //[o autorelease]; //retainCount为1
    [pool release]; //retaincount为0，触发dealloc方法 
</code></pre>

<h1>三、AutoreleasePool使Objective-C成为内存管理半自动化语言</h1>

<p>程序入口</p>

<pre><code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
    int retVal = UIApplicationMain(argc, argv, nil, nil);
    [pool release];
</code></pre>

<p>在 声明pool后，release它之前的这段代码，所有段里的代码（先假设中间没有声明其它的AutoreleasePool实例），凡是调用了 autorelase方法的实例，都会把它的retainCount加1，并在此pool实例中添1次此实例要回收的记录以做备案。当此pool实例 dealloc时，首先会检查之前备案的所有实例，所有记录在案的实例都会依次调用它的release方法。</p>

<pre><code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
    NSObject *o = [[NSObject alloc] init];
    [o autorelease];                                //在pool实例dealloc时，release     一次此实例，重要的是并不是在此行去release
    NSLog(@"o retainCount:%d",[o retainCount]);    //此时还可以看到我们的o实例还是可用的，并且retainCount为1
    [pool release];    //pool 的 retainCount为0，自动调用其dealloc方法，我们之前备案的小o也将在这里release一次（因为咱们之前仅仅autorelease一次）
</code></pre>

<p>真对同一个实例，同一个Pool是可以多次注册备案(autorelease)的。在一些很少的情况化可能会出现这种需求：</p>

<pre><code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
    NSObject *o = [[NSObject alloc] init];
    [o retain];
    [o autorelease];
    [o autorelease];
    [pool release];
</code></pre>

<p>我 们调用了两次A类(retainCount加1的方法)，使其retainCount为2，而接下来的两次autorelease方法调用，使其在 pool中注册备案了两次。这里的pool将会在回收时调用此实例的两次release方法。使其retainCount降为0，完成回收内存的操作，其 实这也是完全按照内存管理规则办事的好处.</p>

<p>AutoreleasePool是被嵌套的！池是被嵌套的，嵌套的结果是个栈，同一线程只有当前栈顶pool实例是可用的：</p>

<p>|  pool_3  |</p>

<p>|  &mdash;&mdash;&mdash;&mdash;-      |</p>

<p>|  pool_2      |</p>

<p>|  &mdash;&mdash;&mdash;&mdash;-   |</p>

<p>|  pool_1  |</p>

<p>|_______|</p>

<pre><code>NSAutoreleasePool *pool1 = [[NSAutoreleasePool alloc] init];
    NSAutoreleasePool *pool2 = [[NSAutoreleasePool alloc] init];
    NSAutoreleasePool *pool3 = [[NSAutoreleasePool alloc] init];

NSObject *o = [[NSObject alloc] init] autorelease];
    [pool3 release];
    [pool2 release];
    [pool1 release];
</code></pre>

<p>我们可以看到其栈顶是pool3，o的autorelease是把当前的release放在栈顶的pool实例管理。。。也就是pool3。
在生命周期短，产生大量放在autoreleasePool中管理实例的情况下经常用此方法减少内存使用，达到内存及时回收的目的。
autorelease pool不是天生的，需要手动创立。只不过在新建一个iphone项目时，xcode会自动帮你写好。autorelease pool的真名是NSAutoreleasePool。</p>

<pre><code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];    NSAutoreleasePool内部包含一个数组（NSMutableArray），用来保存声明为autorelease的所有对象。如果一个对象声明为autorelease，系统所做的工作就是把这个对象加入到这个数组中去。


ClassA *obj1 = [[[ClassA alloc] init] autorelease]; //retain count = 1，把此对象加入autorelease pool中
</code></pre>

<p>NSAutoreleasePool自身在销毁的时候，会遍历一遍这个数组，release数组中的每个成员。如果此时数组中成员的retain count为1，那么release之后，retain count为0，对象正式被销毁。如果此时数组中成员的retain count大于1，那么release之后，retain count大于0，此对象依然没有被销毁，内存泄露。</p>

<p>所有标记为autorelease的对象都只有在这个pool销毁时才被销毁。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2012/04/11/hello-world/"/>
    <updated>2012-04-11T22:13:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2012/04/11/hello-world</id>
    <content type="html"><![CDATA[<p>Hello Octopress !</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Obeject-C语法总结]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2012/03/11/obeject-cyu-fa-zong-jie/"/>
    <updated>2012-03-11T17:50:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2012/03/11/obeject-cyu-fa-zong-jie</id>
    <content type="html"><![CDATA[<p>Objective-C代码的文件扩展名<br />
扩展名   内容类型<br />
.h  头文件。头文件包含类，类型，函数和常数的声明。<br />
.m  源代码文件。这是典型的源代码文件扩展名，可以包含Objective-C和C代码。<br />
.mm 源代码文件。带有这种扩展名的源代码文件，除了可以包含Objective-C和C代码以外还可以包含C++代码。仅在你的Objective-C代码中确实需要使用C++类或者特性的时候才用这种扩展名。<br />
#import选项和#include选项完全相同，＃import只是它可以确保相同的文件只会被包含一次。</p>


<p>字符串<br />
NSString*  myString = @&#8221;My String&#8221;;<br />
用双引号，助记符号  @<!--more--></p>


<p>类<br />
类是Objective-C用来封装数据，以及操作数据的行为的基础结构。对象就是类的运行期间实例，它包含了类声明的实例变量自己的内存拷贝，以及类成员的指针。Objective-C的类规格说明包含了两个部分：接口和实现。接口部分包含了类声明和实例变量的定义，以及类相关的方法。实现部分包含了类方法的实际代码<br />
￼</p>


<p>类声明总是由@interface编译选项开始，由@end编译选项结束。类名之后的（用冒号分隔的）是父类的名字。类的实例（或者成员）变量声明在被大括号包含的代码块中。实例变量块后面就是类声明的方法的列表。每个实例变量和方法声明都以分号结尾。<br />
类实现<br />
类实现总是由@implementation开始，由@end编译选项结束。<br />
+(MyClass *)createMyClassWithString: (NSString *) aName<br />
类方法<br />
-(id)initWithString:(NSString *) aName<br />
实例方法<br />
Objective-C中的类可以声明两种类型的方法：实例方法和类方法。实例方法就是一个方法，它在类的一个具体实例的范围内执行。也就是说，在你调用一个实例方法前，你必须首先创建类的一个实例。而类方法，比较起来，也就是说，不需要你创建一个实例。</p>


<p>￼</p>


<p>方法实际的名字包含了冒号，冒号表明了参数的出现。<br />
[myArray insertObject:anObj atIndex:0];<br />
接收消息的对象在左边，消息（包括消息需要的任何参数）在右边。<br />
[[myAppObject getArray] insertObject:[myAppObject getObjectToInsert] atIndex:0];<br />
消息的嵌套</p>


<p>NSMutableArray*   myArray = nil;    // nil is essentially the same as NULL<br />
// Create a new array and assign it to the myArray variable.<br />
myArray = [NSMutableArray arrayWithCapacity:0];<br />
类方法</p>


<p>属性<br />
属性是用来代替声明存取方法的便捷方式。属性不会在你的类声明中创建一个新的实例变量。他们仅仅是定义方法访问已有的实例变量的速记方式而已。<br />
实际上可以说，属性节约了你必须要些的大量多余的代码。因为大多数存取方法都是用类似的方式实现的，你用属性声明指定你希望的行为，然后在编译期间合成基于声明的实际的getter和setter方法。<br />
属性声明应该放在类接口的方法声明那里。基本的定义使用@property编译选项，紧跟着类型信息和属性的名字。你还可以用定制选项对属性进行配置，这决定了存取方法的行为。下面的例子展示了一些简单的属性声明：<br />
@property BOOL flag;<br />
@property (copy) NSString* nameObject;  // Copy the object during assignment.<br />
@property (readonly) UIView* rootView;  // Create only a getter method.</p>


<p>property是一种代码生成机制，能够生成不同类型的getter／setter函数，特别是如果你想要用点（.）操作符号来存取变量的话，你就能必须使用property。<br />
@s</p>


<p>用法如：@property (attribute1,attribute2) float value;</p>


<p>这些attribute包括：<br />
readonly－只读，只能读取而不能设定值（不能用setXXXX的函式）。<br />
readwrite－可读可写（默认）。<br />
assign－在设值时替换新旧变量（默认）。<br />
retain－在设值时retain新的变量，release旧变量。<br />
copy－在设值时copy一份新变量，release旧变量。<br />
nonatomic－默认為atomic。<br />
前两个只是简单的设定变量的可读写性。</p>


<p>assign只是简单的替换变量，通常运用在标量类型上，例如：NSInterger和CGRect,<br />
或者(在引用计数环境)为那些你不拥有的对象，例如：delegates。<br />
在垃圾收集环境下retain 和 assign实际上是相同的。<br />
它的产生的setter代码內容类似：<br />
retain通常用在对象类型上</p>


<p>使用retain会通知编译器对新的变量发送保留（retain）的信息，以确保变量在程序支行时不会从记忆体中被清除。</p>


<p>copy也是通常用在必须是已经实现NSCopying协议的对象类型上，只是把刚刚retain的地方改成copy，在设定时不retain新的变量，而是copy一份給原变量成員。<br />
通常在新变量為mutable而原变量為immutable时使用，使用copy可以确保原变量仍是immutable。</p>


<p>变量和属性是不同的，属性是建立在变量的基础上的，但是实际上它是方法。<br />
把slef.teststring_B = foo; 转化成[self setTeststring_B:foo]。</p>


<p>property实现的指令有两个：@synthesize和@dynamic</p>


<p>@synthesize 自动生成setter&gettter方法，但也是允许覆盖的.<br />
当你想要让getter或setter做更多的事情或加入新的特性时，就要用@dynamic，这时再用原来的@synthesize覆盖的话，会有警告，然后运行时如果你想用到新加入的特性时，运行会出错<br />
使用@dynamic关键字来告诉编译器，你将通过属性暗示或者直接用方法实现或在运行时使用诸如代码动态加载或其动态方法解析机制来履行此API的约定。<br />
它会抑制编译器在不能找到合适的实现时生成的警告。当您知道该方法将在运行时可用时，就可以使用它。</p>


<p>nonatomic，刚是与多线程有关。默认为atomic是在multi-thread的环境下才会用到。<br />
在一般iPhone开发上，会设定为nonatomic来提高效率。<br />
 atomic的意思就是setter/getter这个函数是一个原语操作。如果有多个线程同时调用setter的话，不会出现某一个线程执行setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样。<br />
nonatomic不保证setter/getter的原语行，所以你可能会取到不完整的东西。</p>


<p>比如setter函数里面改变两个成员变量，如果你用nonatomic的话，getter可能会取到只更改了其中一个变量时候的状态，这样取到的东西会有问题<br />
还有一点非常要注意的就是，在使用property时一定要在前面带上self(如：self.xxx),如果你不这样做，容易造成内存<br />
泄漏。</p>


<p>协议和代理<br />
协议声明了可以被任何类实现的方法。他们仅是定义一个接口，其他的对象去负责实现。你实现了协议里面的方法，就叫做符合协议。<br />
在iPhone OS中协议常用来实现委托对象。委托对象就是一个对象以其他的对象的模式行事。<br />
UIApplication类实现了一个程序需要的行为。<br />
协议的声明跟类接口的声明很像，只是协议没有父类，而且他们不会定义任何实例变量。有一个方法的协议声明：<br />
@protocol MyProtocol<br />
- (void)myProtocolMethod;<br />
@end</p>


<p>数据类型</p>


<p>1、 id：</p>


<p>Objective-C有一种比较特殊的数据类型是id。你可以把它理解为“随便”。</p>


<p>在Objective-C里，一切东西都是指针形式保存，你获取到的就是这个对象在内存的位置。那么id就是你知道这个位置，但是不知道里面是啥的时候的写法。</p>


<p>2、 同一个数组可以保存不同的对象：<br />
 3、BOOL，YES，NO：<br />
你可以认为YES表示C#里的true，NO表示false。而实际上YES是1，NO是0，BOOL本身就是个char</p>


<p>4、IBOutlet、IBAction<br />
IBOutlet就是一个显式的引用访问标记。<br />
IBAction就是一个方法的显式引用标记。 IBOutlet声明插座变量，IBAction声明事件方法，其实可理解为void，只是告诉编译器这些变量和方法是和View上的东东打交道的<br />
IBOutlet是控件的引用，比如我想在程序中对控件进行操作，那么就需要将控件声明为IBOutlet。IBAction是控件要执行的动作或事件</p>


<p>官方对IBAction和IBOutlet的解释   </p>


<p>Interface Builder Constants</p>


<p>Type qualifiers used by Interface Builder to synchronize with Xcode.<br />
#define IBAction void<br />
#define IBOutlet</p>


<p>Constants<br />
IBActionType qualifier used by Interface Builder to synchronize actions. Use this type as the return type of any action methods defined in your project. For examples of how to use this identifier, see Xcode Integration.<br />
Available in iPhone OS 2.0 and later.<br />
Declared in UINibDeclarations.h.</p>


<p>IBOutletIdentifier used to qualify an instance-variable declaration so that Interface Builder can synchronize the display and connection of outlets with Xcode. Insert this identifier immediately before the variable type in any variable declarations. For examples, including how to use it with the @property syntax, see Xcode Integration.<br />
Available in iPhone OS 2.0 and later.<br />
Declared in UINibDeclarations.h.<br />
Discussion<br />
For more information about how to use these constants, see Communicating With Objects. For information about defining and using actions and outlets in Interface Builder, see Interface Builder User Guide.</p>


<p>5、nil。</p>


<p>Objective-C里的NULL（空）就这么写，表示空指针。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scrum]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2011/12/03/scrum/"/>
    <updated>2011-12-03T22:48:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2011/12/03/scrum</id>
    <content type="html"><![CDATA[<p>Scrum</p>


<p>1.解释敏捷</p>


<p>个体与交互胜过过程与工具<br />
可以工作的软件 胜过 面面俱到的文档<br />
客户协作 胜过 合同谈判<br />
响应变化 胜过 遵循计划<br />
简单的四句话很好的解释了敏捷方法的精髓<br />
<!--more--><br />
2.敏捷的12条原则</p>


<p>我们最优先要做的是通过尽早的、持续的交付有价值的软件来使客户满意<br />
即使到了开发的后期，也欢迎改变需求。敏捷过程利用变化来为客户创造竞争优势<br />
经常性的交付可以工作的软件，交付的间隔可以从几周到几个月，交付的时间间隔越短越好。<br />
在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。<br />
围绕被激励起来的人个来构建项目。给他们提供所需要的环境和支持，并且信任他们能够完成工作。<br />
在团队内部，最具有效果并且富有效率的传递信息的方法，就是面对面的交谈。<br />
工作的软件是首要进度度量标准。<br />
敏捷过程提可持续的开发速度。责任人、开发者和用户应该能够保持一个长期的、恒定的开发速度。<br />
不断地关注优秀的技能和好的设计会增强敏捷能力。<br />
简单&#8212;-使未完成的工作最大化的艺术&#8212;-是根本的。<br />
最好的构架、需求和设计出自与自组织的团队。<br />
每隔一定时间，团队会在如何才能更有效地工作方面进行反省，然后相应地对自己的行为进行调整。</p>


<p>Scrum定义</p>


<p>Scrum 方法是遵循敏捷宣言中所列的价值观，基于 12 条敏捷原则，提供了一套术语和流程（如产品 backlog、spint 计划会议指南、站立会议等）作为实践指导，短期迭代的进行有价<br />
值的产品交付。<br />
Scrum 本身并不是方法论，它只是一个框架，它只定义了高层次的管理流<br />
程</p>


<p>4.Scrum特点</p>


<p>Scrum 是一个敏捷的流程，可用于管理和控制研发工作。<br />
Scrum 是现有设计流程的总结。<br />
Scrum 以团队为基础，是一种在要求迅速变化情况下迭代地、增量地开发系统和产品的方法。<br />
Scrum 是一个控制由利益和需求冲突导致的混乱的流程。<br />
Scrum 是改善交流并最优化合作的方式。<br />
Scrum 是一种检测产品开发和生产过程中障碍并将其去除的方式。<br />
Scrum 是最大化生产率的一种方法。<br />
Scrum 适用于单一的项目到整个组织。Scrum 可以控制并组织多件具有相关性的产品开发以及拥有超过千名开发者和执行者的项目实施过程。<br />
Scrum 能让每个参与者都对自己的工作以及自己做出的贡献感到满意，并让他们感觉自己的工作已经达到最佳的水平。<br />
4.核心</p>


<p>Scrum 的核心在于迭代</p>


<p>5.角色<br />
三种角色<br />
产品负责人（Product Owner）、ScrumMaster、团队（Team）。产品负责人负责业务概念与想法（例如backlog），而Scrum Master负责领导Team执行与质量，关注于及时完成Sprint。 </p>


<p>6.职责<br />
ProductOwner </p>


<p>. 确定产品的功能<br />
. 决定发布的日期和发布内容<br />
. 为产品的profitability of the product (ROI)负责<br />
. 根据市场价值确定功能优先级<br />
. 在30天内调整功能和调整功能优先级<br />
. 接受或拒绝接受开发团队的工作成果 </p>


<p>ScrumMaster  </p>


<p>. 清除挡在客户和开发工作之间的拦路虎，客户从而可以直接驱动开发。<br />
. 教导客户如何最大化ROI，以及通过Scrum实现他们的目标。<br />
. 通过激发创造性与推动授权来提升开发团队的成员<br />
. 以任何可能的方式提升开发团队的开发效率<br />
. 改进工程实践和工具，使得每次功能性上的改进都能得以交付 </p>


<p>Scrum Team </p>


<p>. 具有不同特长的团队成员，人数控制在7个左右<br />
. 确定Sprint目标和具体说明的工作成果<br />
. 在项目向导范围内有权利做任何事情已确保达到Sprint的目的</p>


<p>7.过程</p>


<p>启动 Scrum 项目所需的最简约计划包括：一份愿景及产品 Backlog。愿景描述项目开发原因和预期目标。愿景可能描述商业运作方式将发生哪些改变，主 要特性和功能如何为客户创造收益，以及对市场的预期影响。产品 backlog 将定义交付愿景时，系统应满足的功能性和非功能性需求，它需事先划分优先级并经过初始预估（预估的目的是了解每个需求自身及相对与其他需求的规模）。在 Sprint 第一天召开 sprint 计划会议，这个会议分为两部分，计划会议 1由 PO、SM 和 Team 参加，主要是从产品 backlog 中挑 选出需要放 到当前 sprint下的既定产品 backlog，然后由 SM、Team 参加计划会议 2，把既定产品 backlog的故事拆分成任务进行估算，PO 也可以一 起参加这个部分来了解具体的开发细节。sprint 周期在 spirnt 计划会议 2 正式开始。开发过程中，团队每天召开每日站会（Daily Scrum），沟通团队成员间工作进度和进行任务协调。Sprint 周期结束时，需要召开 Sprint 评审会议，由团队向产品负责人和其他利益相关者展示 当前 sprint 周期内的产品开发情况。产品负责人根据团队这次 Sprint 所发布的版本，评审相关的 Backlog 中的问题，检查是否已达到 Sprint 的目标。评审会议结束后会进行回顾会议，通过总结以往的实践经验来提高团队生产力。</p>


<p>8.术语解释</p>


<p>Backlog<br />
Product Backlog</p>


<p>在项目开始的时候，Product Owner 要准备一个根据商业价值排好序的客户需求列表。这个列表就是 Prodct Backlog，一个最终会交付给客户的产品特性列表，它们根据商业价值来排列优先级。Scrum team 会根据这个来做工作量的估计。Product backlog 应该涵盖所有用来构建满足客户需要的产品特性，包括技术上的需求。高优先级的一些产品特性需要足够的细化以便于我们做工作量估计和做测试。对于那些以后将要实现的特性可以不够详细。在下一篇我将着重讲解如何制定 Product Backlog，怎么写故事，如何拆分和合并故事，以及如何确定优先级和进行估算。</p>


<p>Sprint Backlog</p>


<p>Sprint Backlog 是 Sprint 规划会上产出的一个工作成果. Sprint 英文指短距离疾跑，就是说集合精力在短时间内（一个迭代）完成一些价值。当 Scrum team 选择并承诺了 Productbacklog 中要递交的一些高优先级的产品功能点后，这些功能点就会被细化成为 SprintBacklog:一个完成 Product Backlog 功能点的必需的任务列表.这些点会被细化为更小的任务，工作量小于 2 天。Sprint backlog 完成后，Scrum team 会根据它重新估计工作量，如果这些工作量和原始估计的工作量有较大差异，Scrum team 和 Product Owner 协商，调整合理得工作量到 Sprint 中，以确保 Sprint 的成功实施。</p>


<p>会议<br />
Sprint Planning Meeting（Sprint 规划会）</p>


<p>根据 Product Owner 制定的产品或项目计划在 Sprint 的开始时做准备工作。Product Owner 可以是客户或者客户代表或代理。对于产品型的公司，客户就是市场，Product Owner 扮演市场代理的角色。一个 Product Owner 需要一个确定产品最终目标的远景，规划出今后一段时间产品发展的路线图，以及根据对投资回报的贡献确定的产品特性。他要准备一个根据商业价值排 好序的客户需求列表。这个列表就是 Prodct Backlog，一个最终会交付给客户的产品特性列表，它们根据商业价值来排列优先级。当为一个 Sprint 定义好足够多的 Product Backlog，并且排列好优先级后 Scrum就可以开始了，Sprint 规划会是用来细化当前迭代的开发计划的。规划会开始的时候，Product Owner 会和 Scrum team 一起评审版本，路线图，发布计划，及 Product Backlog。Scrum Team 会评审 Product Backlog 中功能点的时间估计并确认这些估计尽可能的准确。Scrum Team 会根据资源情况看有多少 feature可以放在当前的 Sprint 中。Scrum Team 按照优先级的高低来确定开发的先后是很重要的。当 Sprint backlog 确定后，ScrumMaster 带领 Scrum Team 去分解这些功能点，<br />
细化成 Sprint 的一个个任务. 这些任务就是细化的来实施这些功能点的活动.<br />
Sprint Planning 的这个阶段需要控制在 4 个小时。</p>


<p>Daily Scrum Meeting（每日站会）</p>


<p>一旦计划阶段结束，30 天周期的 Sprint 就开始了。ScrumMaster 需要组织团队成员每天开站会. 这个会议是用 15 分钟的时间来让大家过一下 scrum 的状态。在会上，每个团队成员需要问 3 个问题：我昨天做了什么，今天做什么，遇到哪些障碍。谁都可以 参加这个会议，但只有 Scrum 团队成员有发言权。这个会议的目标是得到一个项目的全局观，用于发现任何新的依赖，定位项目成员的要求，实时的调整当天开 发计划.</p>


<p>Sprint Review Meeting（Sprint 评审会）<br />
在Sprint结束的时候召开Sprint评审会. 这个会议最多不超过4个小时.会议的前一半时间用来演示在这个Sprint中开发的产品功能给 ProductOwner.<br />
Produc Owner会组织这阶段的会议并且邀请相关的利益相关者参加。 业务，市场，技术都要做相关的评审。由Product Owner来决定ProductBacklog中的哪些功能已经开发完成 。会议的下半部分，是由Scrum Master和ScrumTeam一起回顾当前的Sprint。团队评估大家在一起的工作方式，找出好的方式以后继续发扬，找出需要做的更好的地方，想办法提升Sprint评审 会结束后，新一轮的迭代又继续开始（中间最好修整半天或者隔个周末），迭代会一直继续，直到开发了足够多的功能去交付一个产品。 </p>


<p>9.如何写故事</p>


<p>一般按照轻量级的故事来进行描述需求。用户故事是最基本的设计单元，它是 从系统用户或者客户的角度出发对功能的一段简要描述。用户故事的形式很自由，没有什么强制性的语法。但是，按照大致符合这样一个形式来考虑 用户故事是比较有益的：“作为【用户的类型】，我希望可以【先这样做，然后那样做，就应该得到&#8230;的结果】以便【业务价值】。”以这样的模作为例子，可 以得到一个用户故事说：“作为购书者，我希望可以根据 ISBN 来找到一本书，以便能更快的找到正确的书。”在做用户故事时，需要注意每个用户故事用的是用户的语言，它只描述一个功能（feature），而且每个用户故事的开发周期不要太长（1<br />
－5 天）我们不需要一开始对所有的故事都进行详细的描述，但计划放在下一个<br />
sprint 中的故事应该比较清楚。</p>


<p>10.如何拆分</p>


<p>当故事非常大时，我们将很难对它进行估计。如果故事预计在 N 次迭代后才进行，那么大的故事很正常。但如果估计预计在接下来的迭代中进行，那么我们就 可能会对大的故事进行拆分。很大的故事基本上都能进行拆分，只要确定每个小故事莹然可以交付业务价值就行。注意在这里不要把故事拆分到任务，故事是可以交 付的东西，是产品负责人所关心的，而任务是不可交付的东西，产品负责人对它并不关心，任务是在 sprint 计划会议上拆分的。<br />
分割用户故事：<br />
按照用户故事所支持数据的边界来分割大型用户故事（例如导入 GBQ 文件、Excel 等）<br />
有些时候，可以从主用户故事中除去对例外或错误条件的处理（相当于用户的基本路径和扩展路径），从而把一个大型用户故事变小许多<br />
按照操作边界分割，把大型用户故事分割成独立的建立、读取、更新和删除操作（例如预算二次导入，或者新增时需要向导、规则而比较复杂时也可以单独成一个故事来描述）<br />
 考虑去除横切考虑（例如安全处理、日志记录、错误处理等），为用户故事建立两个版本：一个具备对横切考虑的支持，另一个不具备这种支持<br />
考虑功能性需求和非功能性需求隔离到不同的用户故事，从而分割大型用户故事（性能）<br />
在拆分故事时，我们有时也需要考虑组合故事的场景，如把 bug 列入产品 backlog<br />
时，可以把多个类似的 bug 组合成一个故事。</p>


<p>11.评定优先级</p>


<p>最简单的方法就是问问客户最希望在下一个迭代中最想看到的是哪一些功能。从<br />
考虑的因素来看，我们可以从以下 5个因素来考虑：</p>


<p> 获取这些功能带来的经济价值，价值越高的优先级越高。<br />
开发成本带来的影响。例如可能 2 个月后由于使用新技术只需要 2 周，而现在做需要 2 个月，这时可以考虑把优先级放低一些<br />
获取新知识的重要性。在开发中会不断的产生一些项目和产品的新知识，及早了解和开发这些新知识可以减少不确定性，所以这类功能优先级会高些<br />
 故事之间会存在依赖关系，这时候被依赖的优先级会更高，需要先完成<br />
开发这些功能所减少的风险。在开发过程中，会出现进度风险、成本风险、技术风险等，对于风险越高价值越大的我们需要首先处理，对风险高价值低的要尽量避免，可以通过以下图查看确定功能优先级时综合考虑风险和价值的关系</p>


<p>12.如何进行评估</p>


<p>对每个故事进行初始估计后就可以知道项目的规模。一般采用故事点来进行这类初始评估，可以通过扑 克牌来进行，扑克牌点数一般有 0、1/2、1、2、3、5、8、13、20、40、100、？、咖啡。首先由产品负责人对 product backlog 进行讲解，然后由 Scrum master负责协调进行初始评估工作。敏捷估算中不是要估计绝对的时间，而是尽量确保故事之间的相对估计是准确的。由于估计是相对的，所以需要首先找打 一个基准，我们可以先找一个不是最小的，也不是最大的来作为一个基准，可以先找出一个大家认为适合分配为 2 点的故事。在找 2 点的故事时，很可能会出现大家 意见不一致的情况，这时就需要大家都分别说明自己的见解后再重新找。有了 2 点基准后，就可以对每个故事进行评估了，而后面的故事都可以基于以前的故事来进 行相对估计了。在估计过程中，有可能会出现大家对故事理解不一致，这时就需要返回去修改故事，确保大家理解一致。</p>


<p>13.自组织个人</p>


<p>Scrum 中有一个很重要的概念，那就是自组织团队。在前面也说过，在个人管理项目中，我们每个人都是这个项目的管理者和执行者，即是导演又是演员，在自己的个人管理项目中，我们同时兼任管理者和被管理者两个角色，要想顺利完成这个项目，我们就必须要求自己是一个高绩效、会学习（知识＋实践＋思考＋心态）、自我管理的人。</p>


<p>从人性方面来看，很少有人愿意被别人管，但是不让别人管只有一个途径，<br />
那就是自己主动、自律、卓越的完成工作。在要求企业以人为本时，我们更不能<br />
单方面要求企业把员工当人，更重要的是员工要把自己当人来看。</p>


<p>以下罗列几点自我管理的重要原则</p>


<p>目标原则：大到职业规划、小到每件事情的目标，对于目标的制定和管理，都需要我们不断的去制定和执行<br />
学习能力：学历代表过去，经验代表现在，而学习能力代表未来，一个人的学习能力决定了他将来的成绩<br />
心态：一个人的态度决定一个人的&#8221;高度&#8221;，激情而投入地做事与麻木而呆滞地做事会导致完全不同的两种结果<br />
要事第一：工作分轻重缓急，不能对事情没有安排和计划，应该对要事需要优先安排<br />
执行力：有目标是方向，没有执行也不会有结果，执行力是事情快速有效完成的保障</p>


<p>这些原则并不是孤立的，其实都是关联的，有目标才知道学习什么，有正确心态才能更好的学习，执行力加上认清要事才能更高效的出更好结果。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[花开荼蘼]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2011/11/01/hua-kai-tu-mi/"/>
    <updated>2011-11-01T21:23:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2011/11/01/hua-kai-tu-mi</id>
    <content type="html"><![CDATA[<p style="text-align: center;"><a href="http://www.flickr.com/photos/mosquitoliu/6962567062/" title="Flickr 上 freefishdss 的 荼蘼花"><img src="http://farm9.staticflickr.com/8141/6962567062_8878a9b42f.jpg" width="480" height="360" alt="荼蘼花"></a></p>




<p> 荼靡花开，花事荼靡，一株佛家经典里孤独寂寞的彼岸花，居然，是花中十友排行第十的韵友。想来谁也不信，荼靡的寂寞，是所有花中最持久，最深厚，也是最独特的。茶蘼是花季最后盛放的鲜花，茶蘼花开过之后，人间再无芬芳。只剩下开在遗忘前生的彼岸的花。</p>


<!--more-->


<p> 今年好是折腾。从三月分开始就没有消停过。<br />
    三月。爸妈来学校陪我住了一个月。<br />
    七月。回家一个星期。<br />
    九月。老爸重返成都给我的牙整容。<br />
    十月。回家两个星期，参加婚礼、干儿子的白天、调整。</p>


<p> 很是不顺，开始找到了实习的地方。导师不让去。被导师不停的忽悠。最近继续找成都附近的实习，都没有回应。又开始失眠，睡不着了。</p>


<p> 老爸继续在生我的气。无话。<br />
    暂定过年不回家了。</p>


<p> 一切有为法,尽是因缘合和,缘起时起，缘尽还无，不外如是。只是那伤痕却永不痊愈了，一一成为胎记，在往生的路上，如莲花开落，使你可以辨认。荼蘼是花季最后盛放的花，开到荼蘼花事了，只剩下开在遗忘前生的彼岸的花。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Synergy]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2011/09/19/synergy/"/>
    <updated>2011-09-19T02:18:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2011/09/19/synergy</id>
    <content type="html"><![CDATA[<p>Synergy 是一款能够让使用者仅用一套键盘鼠标，就同时操控多部计算机的免费工具软件。使用者能够在包括 Windows 、 Linux 、 Mac OS 等不同的系统上安装它，并且在设定好主从关系后，就能够透过一组键盘鼠标来进行多部计算机的操控。『官方网址：<a href="http://synergy-foss.org"><a href="http://synergy-foss.org">http://synergy-foss.org</a></a>/』<!--more-->下载对应系统的客户端。我的是Window7和Mac OS。Windows 1.4.4beta 32-bit;Mac OS X Universal。</p>

<p>安装好后，开始进行配置。（Windows7作为server，Mac OS作为Cliernt）</p>

<p>Windows7下的配置（如下图）</p>

<p><a href="http://pic.mosquitoliu.com/wp-content/uploads/2011/09/3.png"><img class="aligncenter size-full wp-image-421" title="3" src="http://pic.mosquitoliu.com/wp-content/uploads/2011/09/3.png" alt="" width="517" height="375" /></a><a href="http://mosquitoliu.com/wp-content/uploads/2011/09/2.jpg"><img class="aligncenter size-full wp-image-422" title="2" src="http://mosquitoliu.com/wp-content/uploads/2011/09/2.jpg" alt="" width="517" height="371" /></a></p>

<p>要正确的填写计算机的名称。</p>

<p><a href="http://pic.mosquitoliu.com/wp-content/uploads/2011/09/1.jpg"><img class="aligncenter size-full wp-image-423" title="1" src="http://pic.mosquitoliu.com/wp-content/uploads/2011/09/1.jpg" alt="" width="520" height="372" /></a><a href="http://mosquitoliu.com/wp-content/uploads/2011/09/6.jpg"><img class="aligncenter size-full wp-image-424" title="6" src="http://pic.mosquitoliu.com/wp-content/uploads/2011/09/6.jpg" alt="" width="335" height="278" /></a></p>

<p>这样windows7的配置就完成了。点击Start，运行。</p>

<p>Mac OS下的配置（如下图）</p>

<p><a href="http://pic.mosquitoliu.com/wp-content/uploads/2011/09/5.jpg"><img class="aligncenter size-full wp-image-425" title="5" src="http://pic.mosquitoliu.com/wp-content/uploads/2011/09/5.jpg" alt="" width="473" height="413" /></a></p>

<p>点击Start运行。</p>

<p>这时Windows7下的图标变成了如图所示</p>

<p><img class="aligncenter size-full wp-image-426" title="4" src="http://pic.mosquitoliu.com/wp-content/uploads/2011/09/4.jpg" alt="" width="66" height="48" /></p>

<p>这表示连接成功。滑动鼠标可以从Windows窗口滑到Mac OS的窗口了。</p>

<p>&nbsp;</p>

<p>PS：当Mac OS作为Server，Windows7作为Client时，没有设置成功。原因不详。</p>

<p>&nbsp;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pet Diary six]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2011/08/16/pet-diary-six/"/>
    <updated>2011-08-16T12:55:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2011/08/16/pet-diary-six</id>
    <content type="html"><![CDATA[<p><embed type="application/x-shockwave-flash" width="480" height="400" src="http://player.youku.com/player.php/sid/XMjk1MTM4ODY0/v.swf" allowfullscreen="true" quality="high" align="middle" allowscriptaccess="always"></embed></p>


<p>狗狗发情了！！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[诞生]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2011/07/05/dan-sheng/"/>
    <updated>2011-07-05T02:23:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2011/07/05/dan-sheng</id>
    <content type="html"><![CDATA[<p>二零一一年七月四日，二十二点零七分，我发小儿的宝宝来到了这个世上，七斤四。不算胖，但个子还蛮大的。替他们感到非常的高兴。我也当干爹了。</p>


<div>很想能自己也有一个自己的宝宝。想结婚，想要孩子。。。。。。。。</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pet Diary five]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2011/05/28/pet-diary-five/"/>
    <updated>2011-05-28T21:49:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2011/05/28/pet-diary-five</id>
    <content type="html"><![CDATA[<p>我都不好意思把狗狗的照片传上来了。昨天给狗狗的胎毛都给剃了，还净了脸，现在是太丑太丑了，我都不忍心看下去了，现在好悔不该全剃掉，这该肿么办啊？</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不幸的夜]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2011/05/24/bu-xing-de-ye/"/>
    <updated>2011-05-24T22:07:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2011/05/24/bu-xing-de-ye</id>
    <content type="html"><![CDATA[<p>五月十七日晚上，九点左右接到光光打来的电话，说，他们很快就到科大了，叫我去门口接他们，他们从川大骑自行车过来。<!--more--></p>


<div>见到他们之后，请他们几个去吃东西，喝了点酒，喝的晕！@o@&#8221;了。吃好之后他们骑自行车又回去了，真的佩服他们的体力。我一个人骑车回寝室，不幸就这样发生了，在快到寝室的路上装上了自行车，我急刹车，然后整个人飞了出去，和大地进行了一次轻微的较量，结果我输了。三颗门牙被磨齐了，也开始松动了，我在地上躺了五分多钟才爬起来，自己回到寝室吃了止痛片，胳膊扭到了，现在还肿着，这两天可能是阴天的关系，一直很疼，身上都是擦伤，还好我还活着，难受的是吃东西，现在太费劲了。现在的我出门都带口罩~</div>


<div>我要抓时间赶紧去烧香拜佛了，去去厄运~~~</div>


<p>&nbsp;</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pet Diary four]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2011/05/24/pet-diary-four/"/>
    <updated>2011-05-24T20:58:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2011/05/24/pet-diary-four</id>
    <content type="html"><![CDATA[<p style="text-align: center;"><embed type="application/x-shockwave-flash" width="480" height="400" src="http://player.youku.com/player.php/sid/XMjY5Nzc3MTU2/v.swf" quality="high" align="middle" allowscriptaccess="sameDomain"></embed><br />


到今天为止狗狗和我一起生活了一个月零六天了，在这一个月的时间里，狗狗给我带来了很多的快乐。狗狗越来越离不开我了。</p>


<p>今天第二次给狗狗洗澡，狗狗很乖，貌似很是享受，但是给他用吹风机吹毛的时候，他貌似不是很舒服，趴在窝里，头埋的很低，废了很大的劲才给他吹干毛。<!--more--></p>


<p>昨天我去洗澡，把狗狗放在同学那里叫同学帮我看一下，没想到，狗狗跑到浴室来找我了，确实还是有点小小的的感动咯～～○|￣|_ =3</p>


<p>前些天带狗狗出去溜，发现狗狗在外边的胆子好小啊，和我是寸步不离。</p>


<p>狗狗长的很快，现在一顿饭要吃70颗狗粮了（╮(￣▽￣&#8221;)╭ 每次都要给他数，严格控制食量），隔一天还要给他一个鸡蛋黄吃，隔三差五还要给他酸奶喝，╮(╯▽╰)╭生活条件好的哇(PД`q。)·。&#8217;゜现在狗狗的伸长已经有39cm了。</p>


<p>这两天在我的寝室拉了两次便便了，不去阳台拉了，ε=怒ε=怒ε=怒ε=怒ε=( o｀ω′)ノ，恶狠狠的教训了狗狗，教训完之后看到狗狗可怜巴巴的样子儿，心里又于心不忍在打他了。</p>


<p>狗狗是越来越聪明了，为了想出去，他平时都趴在我的书包上睡觉（我出去要背书包），只有晚上才去自己的窝里睡。总想跟着我一起出去……</p>


<p>PS：失踪将近一个月的小乌龟，找到了，不幸的是，他已经去世了，眼珠都没有了，样子很是恐怖哎，都是我的罪过，阿弥陀佛。改天天气好的时候，找个地方给他埋了……</p>


<p>&nbsp;</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[母亲节]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2011/05/08/mu-qin-jie/"/>
    <updated>2011-05-08T21:02:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2011/05/08/mu-qin-jie</id>
    <content type="html"><![CDATA[<p>老妈，节日快乐！这辈子做您的儿子是我的福分，下辈子我还要做您的儿子。下辈子您看到您儿子两个咪咪不一样大，毛毛从小腿一直长到屎眼的，不听话，能花钱的，那没错准是我！哈哈～</p>


<p>祝妈妈，仙福永享，寿与天齐。永远健康快乐！！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pet Diary three]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2011/05/07/pet-diary-three/"/>
    <updated>2011-05-07T01:36:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2011/05/07/pet-diary-three</id>
    <content type="html"><![CDATA[<p>狗狗，和我在一起一共有18天了。在这些日子里，狗狗长大了 ，毛长了，长胖了，更加听话了。</p>


<p>现在我每次出门的时候，狗狗都会紧紧的跟着我，我要和狗狗比赛赛跑，不然的话它就会跟着我跑出去了，O__O”…我出去后，他就开始叫，估计是他自己也不想单独的呆在寝室……<!--more--></p>


<p>昨天晚上把我吓坏了，狗狗[吐]( &gt;ρ &lt; “)了，令我吃惊的是，狗狗又把自己吐的东西吃回去了，有点小恶。估计是他吃好饭我就带他在楼道里跑步的原因吧，下次要注意了，吃好饭不能叫他剧烈的运动了。还好，今天没有出现异常的状况，和往常一样生龙活狗了~</p>


<p>撒娇的本领有增长了，他闷了就曾我的腿，然后自己就躺在地上，肚子朝上，叫我去抚摸他，现在狗狗越长越耐人儿可爱了，嘎嘎\(^o^)/~</p>


<p>&nbsp;</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给老师的Email]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2011/05/05/gei-lao-shi-de-email/"/>
    <updated>2011-05-05T08:36:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2011/05/05/gei-lao-shi-de-email</id>
    <content type="html"><![CDATA[<p>朱老师：</p>

<p>您好。</p>

<p>首先感谢您在这学期给我们含辛茹苦的授课，在您的课上我收获颇多。使我开阔了视野，在您的闲谈当中使我知道了许多之前我并不知道的事情，扩宽了我那小的思维想法。在您的最后一堂课上，你最后赠给我们两句话，在我看来真的是不夸张的说是金玉良言，我会牢牢的记住。<!--more--></p>

<p>淡泊名利。是啊，人活在这个世界上，是多么的不容易。“天下熙熙皆为利来，天下攘攘皆为利往”，“亲朋道义因财失，父子情怀为利休”。利和名，在当今的社会中有多少人在面对他们的时候，能做到笑而过之，不贪之名，不图其利。我自己也在深深思考这个问题，当他们摆在我的面前时，我能做到处之泰然吗？回答是否定的，也许是因为我的阅历尚浅看不透世间的沉浮，总是幻想着自己能赚到大钱，我知道这样的想法很庸俗；也许是因为自己年轻浮躁，摆不正自己的位置，求学到底是为了什么？那些求学是为了报效祖国这类的话，我听过无数遍，但是总是感觉和自己是那么远，不亲近。但是当您说到生命的本质是好好的活着的时候，使我为之而动容。感觉自己一下子明白了什么，但是又是那么的模糊，也许随着年龄的增长，阅历的增加会有更深的体会吧。就像老师所说的那样生命的本身本就是没有意义的，其产生也是一系列的偶然事件交错的发生而形成的。</p>

<p>人活着就是为了活着。眼前的得与失，祸与福，只是暂时的云烟，一缕浮云而已。不要计较的太多，为了活着而活着。三十年河东三十年河西，塞翁失马安知祸福。谁又能准确的预测出将来是个怎样的状况。所以不要计较得与失好好的活着，不是为了别的，只是单纯的为了活着，淡泊名利。</p>

<p>把握当前。这使我想到马尔可夫理论，未来只与现在有关，和过去无关。不要为了空想的未来而放弃现在的努力，没有现在的努力，再怎么想也只是空想而已到头来换的还是一场空。</p>

<p>老舍在《茶馆中》中写的一段台词：“年轻时有牙没有花生豆，老了有花生豆没有牙”。珍惜现在所拥有的一切，通过努力来使自己有牙的时候也有花生豆吃，不会到了老了以后回想起自己以前的碌碌无为而悔恨终生。我们现在的年轻就是资本，认真的走好眼前的每一步，踏踏实实的走向明天，把握当前。
罗里罗嗦的说了这么多，耽误了您的宝贵时间，深表歉意。</p>

<p>最后祝您和您的家人：      身体健康，工作顺利！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[想你]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2011/05/03/xiang-ni/"/>
    <updated>2011-05-03T12:56:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2011/05/03/xiang-ni</id>
    <content type="html"><![CDATA[<p>只是这样的想着你，拿不起，放不下，沉甸甸的悬在胸口憋得我难受。你的行囊里装下了些什么，为什么沉甸甸的让我舍不得。我只知道我的心永远不会离开你，因为你的手里紧紧攥着我心房的线。我能听到你的脚步，感受你的呼吸，甚至常常闭上眼睛能清晰的看到你的脸庞。如果这些鲜活的事物，能放在冰箱里一直保存下去，是多么好的一件事情。<!--more--></p>

<p>风吹过的时候，我托它捎去我的祝福，不知道你是否能听到；雨过的时候，我托它捎去一件寒衣，却不知道那件衣在何处？</p>

<p>沉沦的灵魂总有耐人寻味的故事。时光飞逝，想回到从前，现在匆匆的脚步叩响了我门扉，我开始恐慌，不安，只有不断的努力，不断的加油。在冲往幸福的终点的途中我左脚和右脚都是油门，在这个征途中我无怨无悔的奋力的奔跑。</p>

<p>曾想抬头能望见晴空，但是不想乌云何时已遮住太阳，心中多了几分焦灼，更加平添了几分思念，是对你深深的思念。心里不由自主的涌现出几句词：我爱你，真的很爱很爱你，宝贝儿！这是怎样的风景呢，一而再，再而三，桃花依旧。</p>

<p>想你的时候，总会期待你站在我的身边，用温暖的眼神望着我的存在，我们彼此相拥，甜蜜的吻着对方。时间点点滴滴的过去，希望伴随着我们的幸福一起变的灿烂。</p>

<p>想你，深深的想你！</p>

<p>&nbsp;</p>
]]></content>
  </entry>
  
</feed>
