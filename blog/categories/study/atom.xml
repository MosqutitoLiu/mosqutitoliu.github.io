<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Study | MosquitoLiu's Blog]]></title>
  <link href="http://blog.mosquitoliu.com/blog/categories/study/atom.xml" rel="self"/>
  <link href="http://blog.mosquitoliu.com/"/>
  <updated>2014-03-03T23:08:05+08:00</updated>
  <id>http://blog.mosquitoliu.com/</id>
  <author>
    <name><![CDATA[小文]]></name>
    <email><![CDATA[freefishdss@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UIButton-Image和Title共显]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/03/03/button-displayed-simultaneously-image-and-title/"/>
    <updated>2014-03-03T16:45:22+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/03/03/button-displayed-simultaneously-image-and-title</id>
    <content type="html"><![CDATA[<p>一般情况下设置button的setBackgroundImage，然后setTitle,这样button的image和title都能显示正常。
有时候需要设置button的setImage，在这种情况下再设置setTitle会发现没有共同显示，只是看到image看不到title。其原因是title的位置出现了错误，title的坐标是相对image的坐标。</p>

<p>如：image为下图所示</p>

<iframe src="https://www.flickr.com/photos/mosquitoliu/12905710443/player/30106a7a12" height="48" width="120"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>添加显示title
```objc
……
UIImage *isSubscriptionImage = [UIImage imageWithNameOnly:kIsSubscriptionImageName];</p>

<pre><code>[self.subscriptionButton setTitle:kIsSubscriptionTitleNSString
                         forState:UIControlStateNormal];
[self.subscriptionButton setImage:isSubscriptionImage
                         forState:UIControlStateNormal];
[self.subscriptionButton setTitleColor:RGB(84, 185, 252)                                 
                          forState:UIControlStateNormal];

self.subscriptionButton.contentHorizontalAlignment = UIControlContentHorizontalAlignmentRight;
/** 设置title的坐标 */
[self.subscriptionButton setTitleEdgeInsets:UIEdgeInsetsMake(0, -isSubscriptionImage.size.width - 10, 0, 10)];
……
</code></pre>

<p>```
效果如下所示：</p>

<iframe src="https://www.flickr.com/photos/mosquitoliu/12905989023/player/1d4e627ca6" height="48" width="120"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UILabel设置text显示不同颜色不同字体]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/03/03/label-different-color-and-font/"/>
    <updated>2014-03-03T14:43:10+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/03/03/label-different-color-and-font</id>
    <content type="html"><![CDATA[<p>```objc</p>

<p>……</p>

<p>UILabel *countLabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 10, 150, 14)];</p>

<p>NSString *text =[NSString stringWithFormat:@&ldquo;共有%d条评论&rdquo;,self.datasource.total];</p>

<p>countLabel.attributedText = [self setCmtHeaderViewLabel:text];</p>

<p>……</p>

<p>/<em><em>
 * 设置label.text中的数字和文字的颜色
 * 数字-RGB(51, 51, 51)
 * 文字-RGB(102, 102, 102)
 </em>/
&ndash; (NSAttributedString </em>)setCmtHeaderViewLabel:(NSString *)text
{</p>

<pre><code>/** 转为可变属性的字符串 */
NSMutableAttributedString *attrText = [[[NSMutableAttributedString alloc] initWithString:text] autorelease];
[attrText addAttribute:(NSString *)NSFontAttributeName
                 value:(id)[[UIFont systemFontOfSize:15] CTFonter]
                 range:NSMakeRange(0, text.length)];
[attrText addAttribute:(NSString *)NSForegroundColorAttributeName
                 value:(id)RGB(102, 102, 102).CGColor
                 range:NSMakeRange(0, text.length)];
[attrText addAttribute:(NSString *)NSForegroundColorAttributeName
                 value:(id)RGB(51, 51, 51).CGColor
                 range:NSMakeRange(2, text.length - 5)];
return attrText;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[instancetype关键字]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/02/09/instancetype-keyword/"/>
    <updated>2014-02-09T11:14:55+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/02/09/instancetype-keyword</id>
    <content type="html"><![CDATA[<p>instancetype关键字，保证了编译器能够正确推断方法的返回的类型。</p>

<p><a href="http://clang.llvm.org/docs/LanguageExtensions.html#objective-c-features">Clang</a>的文档里提到 &ldquo;instancetype is a contextual keyword that is only permitted in the result type of an Object-C method&rdquo; 也就是说,instancetype只能作为返回值，不能像id那样作为参数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC_笔记]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/01/21/arc-note/"/>
    <updated>2014-01-21T17:53:07+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/01/21/arc-note</id>
    <content type="html"><![CDATA[<ul>
<li> dealloc

<ul>
<li>释放一些不在ARC控制下的资源。如Core Foundation对象中调用CFRelease()，对那些通过malloc()分配的内存调用free(),注销通知，停止Timer。</li>
</ul>
</li>
<li> 归零弱引用

<ul>
<li>归零弱引用指针，当他指向的对象被销毁时，系统会自动设置为nil</li>
</ul>
</li>
<li> 混合支持ARC与不支持ARC

<ul>
<li>-fno-objc-arc</li>
<li>-fobjc-arc</li>
</ul>
</li>
<li> 编译时支持ARC而文件的代码不支持ARC</li>
</ul>


<p>```objc</p>

<h1>if !<strong>has</strong>feature(objc_arc)</h1>

<p>//这里是不支持ARC的代码
&ndash; (void)dealloc
{
//在这里释放
}</p>

<h1>endif</h1>

<p>```</p>

<!--more-->


<ul>
<li> 框架中使用ARC代码

<ul>
<li>使用宏提示</li>
</ul>
</li>
</ul>


<p>```objc</p>

<h1>if ! <strong>has</strong>feature(objc_arc)</h1>

<h1>error This file is ARC only</h1>

<h1>endif</h1>

<p>```</p>

<ul>
<li> __unsafe_unretained

<ul>
<li>当你没有指针但想要保存指向某物的引用时，可以是使用__unsafe_unretained</li>
</ul>
</li>
<li> __weak

<ul>
<li>与__unsafe_unretained修饰符非常相似。只是当指针指向的内容被销毁后，弱指针便会成为空值（nil）</li>
<li>仅支持iOS5及以上的系统</li>
<li>声明weak之后，无需在viewDidUnload中将其置为nil</li>
</ul>
</li>
<li> __auto_releasing

<ul>
<li>从方法返回一个自动释放变量时使用</li>
<li>无法用在属性上</li>
</ul>
</li>
<li> 所有权修饰符与常量修饰符不同，它是位置无关的

<ul>
<li><strong>weak NSObject *myObject;和NSObject </strong>weak *myObject;意义是一样的。因为ARC的所有权修饰符是对指针起作用的而不是指向的值。</li>
</ul>
</li>
<li> __bridge

<ul>
<li>普通的转换，它告诉ARC不要增加他的引用计数的值，也不改变所有权</li>
</ul>
</li>
<li> __bridge_retained

<ul>
<li>转换C指针类型并增加引用计数的值</li>
</ul>
</li>
<li> __bridge_transfer

<ul>
<li>将Core Foundation指针类型转换成为Object-C指针并为引用计数加一</li>
</ul>
</li>
<li> 强行忽略警告</li>
</ul>


<p>```objc</p>

<h1>pragma clang diagnostic push</h1>

<h1>pragma clang diagnostic ignored “-Warc-perfprmSelector-leaks”</h1>

<pre><code> [self performSelector:self.mySelector];
</code></pre>

<h1>pragma clang diagnostic pop</h1>

<p>```</p>

<ul>
<li> 避免循环保留</li>
</ul>


<p>```objc
<strong>weak typeof(<em>self) </em>this = self; //iOS 5+
</strong>unsafe_unretained typeof(<em>self) </em>this = self;// iOS 4+</p>

<p>self.myBlock = ^(NSString *returnedString){
this.labelControl.text = returnedString;
}
```</p>

<ul>
<li> CFSTR()从一个制定的字符串中创建一个CFStringRef对象。</li>
<li> @autoreleasepool{}

<ul>
<li>当一段代码加入了大量的autorelease变量时</li>
<li>如果在主线程外使用cocoa调用，例如foundation应用，或者detach一个线程，需要创建自动释放池</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2012/04/23/arc/"/>
    <updated>2012-04-23T02:49:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2012/04/23/arc</id>
    <content type="html"><![CDATA[<h1>工作原理</h1>

<p>自动计数（ARC）是一个编译期间工作的能够帮你管理内存的技术。
ARC在编译期间为每个Objective-C指针变量添加合适的retain, release, autorelease等函数，保存每个变量的生存周期控制在合理的范围内，以期实现代码上的自动内存管理。
In order for the compiler to generate correct code, ARC imposes some restrictions on the methods you can use, and on how you use toll-free bridging (see “Toll-Free Bridged Types”); ARC also introduces new lifetime qualifiers for object references and declared properties.</p>

<h1>功能</h1>

<p>ARC使得你不需要再思考何时使用retain,release,autorelease这样的函数来管理内存，它提供了自动评估内存生存期的功能，并且 在编译期间自动加入合适的管理内存的方法。编译器也会自动生成dealloc函数。</p>

<!--more-->


<h1>新规则</h1>

<ul>
<li><p>不能直接调用dealloc方法，不能重载或直接调用retain, release, retainCount,或 autorelease等方法。但可以通过@selector(retain), @selector(release)这样的形式调用。</p></li>
<li><p>用户自定义的dealloc方法，不能调用[super dealloc] ，编译器会自动帮你添加这个代码。</p></li>
<li><p>对Core Foundation-style 的对象，仍可以使用CFRetain, CFRelease等方法。</p></li>
<li><p>不能使用NSAllocateObject或NSDeallocateObject去创建对象，请使用alloc方法。</p></li>
<li><p>在c语言中的结构体中，不能再使用对象指针。请放弃C结构体，使用Objective-C的类。</p></li>
<li><p>id和void*之间没有隐式的类型转换，请使用显式类型转换。</p></li>
<li><p>不能使用NSAutoreleasePool *pool= ARC提供了@autoreleasepool语句块。</p></li>
</ul>


<h1>关于对象的生命周期</h1>

<p>设置成weak的属性，不会影响对象的生命周期，如果引用的对象已经被释放，引用会指向nil。 strong引用：设置成strong的属性，会影响对象的生命周期。</p>

<p>例如：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(strong) MyClass *myObject;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>和</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(retain) MyClass *myObject;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>是等效的。</p>

<p>又例如：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(weak) MyClass *myObject;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>和</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(assign) MyClass *myObject;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在多数情况下等效，但当instance被释放时，设置为weak的引用会指向nil。
可用的限定词： strong， 默认的 weak <strong>unsafe_unretained，和weak的区别是当对象被释放时，引用不指向nil。 </strong>autoreleasing，当方法的参数是id*，且希望方法返回时对象被autoreleased，可以添加<strong>autoreleasing限定词。 使用</strong>weak时要特别小心，如果weak引用的对象在此次使用之前被使用过一次，那么它一直存在，直到autoreleasepool释放它，否则就是nil。</p>

<p>例如</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString __weak *string = [[NSString alloc] initWithFormat:@&ldquo;First Name: %@&rdquo;, [self firstName]];   
</span><span class='line'>string = NSLog(@&ldquo;string: %@&rdquo;, string); //此时string为空，因为weak类型不影响对象的生命周期，对象刚创建就释放了。</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其他特性： 使用strong, weak, autoreleasing限定的变量会被隐式初始化为nil。</p>

<p>例如：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)myMethod { NSString *name; NSLog(@&ldquo;name: %@&rdquo;, name); //会输出null }</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>weak与assign很像,不同在于如果指向的数据被释放了,那么这个指向nil
unsafe_unretained
相当于assign,指向的数据如果被释放,这个指向原来的地址。</p>

<h1>禁用在Xcode中的特定文件的ARC</h1>

<p>选择项目->Build Phases->Compile Sources,，给需要禁止arc的文件添加 “-fno-objc-arc”（双击该文件）编译标志(Compiler Flags)。</p>

<p>如下图</p>

<p style="text-align: center;"><a href="http://www.flickr.com/photos/mosquitoliu/6956821194/" title="Flickr 上 freefishdss 的 noarc"><img src="http://farm9.staticflickr.com/8013/6956821194_ae58ab56c6.jpg" width="500" height="117" alt="noarc"></a></p>


<h1>注意事项</h1>

<ol>
<li>不可以使用retain,retainCount,release,autorelease 用@select()这样的调用也不行.属性命名不能以new开头。</li>
<li><p>若重写一个类子类的dealloc,不应调用[super dealloc],当然也不用写什么release释放一些什么对象,只是处理一些你觉得必要处理的事情吧,比如中止一个还没有完成的网络请求.</p></li>
<li><p>不能使用NSAllocateObject和NSDeallocateObject</p></li>
<li><p>你不能在c结构中使用对象,更好的方式是使用Objective-c类来代替.</p></li>
<li><p>在id和void*之间不能隐士转换，必须指明相应转换的生命周期。</p></li>
<li><p>不能使用NSAutoreleasePool对象，ARC使用@autoreleasepool{}块代替。</p></li>
</ol>


<h1>Core Foundation 对象与Objective-c对象之间的赋值,函数调用参数相互转化时需要用到的关键字</h1>

<p>__bridge</p>

<p>简单赋值,不会影响两边对象的retain count.</p>

<p>__bridge_transfer</p>

<p>赋值后释放右边的对象</p>

<p>__bridge_retained</p>

<p>赋值后也保留不释放右边的对象</p>

<p>举例:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&ndash;(void)test&lt;br/>
</span><span class='line'>{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>CFStringRef coreFoundationString = CFStringCreateWithCString(CFAllocatorGetDefault(),"C String", kCFStringEncodingUTF8);    // 创建 retainCount = 1
</span><span class='line'>id unknownObjectType = (__bridge id)coreFoundationString; // 简单赋值,不变,retainCount = 1
</span><span class='line'>CFStringRef anotherString = (__bridge_retained CFStringRef)unknownObjectType; // 保留赋值,加一,retainCount = 2
</span><span class='line'>NSString *objCString = (__bridge_transfer NSString *)coreFoundationString; // 释放赋值,减一,retainCount =1;由于NSString*默认strong,加一,retainCount = 2
</span><span class='line'>NSLog(@"String = %@", objCString);
</span><span class='line'>objCString = nil;   // 不再指向原内存,原内存减一,retainCount = 1
</span><span class='line'>CFRelease(anotherString);   // 释放,减一,retainCount = 0
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在c型的结构中使用objective-c对象</p>

<p>使用void*代替id;或者使用__unsage_unretained 修饰objective-c对象</p>
]]></content>
  </entry>
  
</feed>
