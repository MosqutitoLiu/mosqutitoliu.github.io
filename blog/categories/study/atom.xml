<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Study | MosquitoLiu's Blog]]></title>
  <link href="http://blog.mosquitoliu.com/blog/categories/study/atom.xml" rel="self"/>
  <link href="http://blog.mosquitoliu.com/"/>
  <updated>2014-03-03T15:27:06+08:00</updated>
  <id>http://blog.mosquitoliu.com/</id>
  <author>
    <name><![CDATA[小文]]></name>
    <email><![CDATA[freefishdss@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UILabel设置text显示不同颜色不同字体]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/03/03/label-different-color-and-font/"/>
    <updated>2014-03-03T14:43:10+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/03/03/label-different-color-and-font</id>
    <content type="html"><![CDATA[<p>```objc</p>

<p>……</p>

<p>UILabel *countLabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 10, 150, 14)];</p>

<p>NSString *text =[NSString stringWithFormat:@&ldquo;共有%d条评论&rdquo;,self.datasource.total];</p>

<p>countLabel.attributedText = [self setCmtHeaderViewLabel:text];</p>

<p>……</p>

<p>/<em><em>
 * 设置label.text中的数字和文字的颜色
 * 数字-RGB(51, 51, 51)
 * 文字-RGB(102, 102, 102)
 </em>/
&ndash; (NSAttributedString </em>)setCmtHeaderViewLabel:(NSString *)text
{</p>

<pre><code>/** 转为可变属性的字符串 */
NSMutableAttributedString *attrText = [[[NSMutableAttributedString alloc] initWithString:text] autorelease];
[attrText addAttribute:(NSString *)NSFontAttributeName
                 value:(id)[[UIFont systemFontOfSize:15] CTFonter]
                 range:NSMakeRange(0, text.length)];
[attrText addAttribute:(NSString *)NSForegroundColorAttributeName
                 value:(id)RGB(102, 102, 102).CGColor
                 range:NSMakeRange(0, text.length)];
[attrText addAttribute:(NSString *)NSForegroundColorAttributeName
                 value:(id)RGB(51, 51, 51).CGColor
                 range:NSMakeRange(2, text.length - 5)];
return attrText;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[instancetype关键字]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/02/09/instancetype-keyword/"/>
    <updated>2014-02-09T11:14:55+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/02/09/instancetype-keyword</id>
    <content type="html"><![CDATA[<p>instancetype关键字，保证了编译器能够正确推断方法的返回的类型。</p>

<p><a href="http://clang.llvm.org/docs/LanguageExtensions.html#objective-c-features">Clang</a>的文档里提到 &ldquo;instancetype is a contextual keyword that is only permitted in the result type of an Object-C method&rdquo; 也就是说,instancetype只能作为返回值，不能像id那样作为参数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC_笔记]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/01/21/arc-note/"/>
    <updated>2014-01-21T17:53:07+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/01/21/arc-note</id>
    <content type="html"><![CDATA[<ul>
<li> dealloc

<ul>
<li>释放一些不在ARC控制下的资源。如Core Foundation对象中调用CFRelease()，对那些通过malloc()分配的内存调用free(),注销通知，停止Timer。</li>
</ul>
</li>
<li> 归零弱引用

<ul>
<li>归零弱引用指针，当他指向的对象被销毁时，系统会自动设置为nil</li>
</ul>
</li>
<li> 混合支持ARC与不支持ARC

<ul>
<li>-fno-objc-arc</li>
<li>-fobjc-arc</li>
</ul>
</li>
<li> 编译时支持ARC而文件的代码不支持ARC</li>
</ul>


<p>```objc</p>

<h1>if !<strong>has</strong>feature(objc_arc)</h1>

<p>//这里是不支持ARC的代码
&ndash; (void)dealloc
{
//在这里释放
}</p>

<h1>endif</h1>

<p>```</p>

<!--more-->


<ul>
<li> 框架中使用ARC代码

<ul>
<li>使用宏提示</li>
</ul>
</li>
</ul>


<p>```objc</p>

<h1>if ! <strong>has</strong>feature(objc_arc)</h1>

<h1>error This file is ARC only</h1>

<h1>endif</h1>

<p>```</p>

<ul>
<li> __unsafe_unretained

<ul>
<li>当你没有指针但想要保存指向某物的引用时，可以是使用__unsafe_unretained</li>
</ul>
</li>
<li> __weak

<ul>
<li>与__unsafe_unretained修饰符非常相似。只是当指针指向的内容被销毁后，弱指针便会成为空值（nil）</li>
<li>仅支持iOS5及以上的系统</li>
<li>声明weak之后，无需在viewDidUnload中将其置为nil</li>
</ul>
</li>
<li> __auto_releasing

<ul>
<li>从方法返回一个自动释放变量时使用</li>
<li>无法用在属性上</li>
</ul>
</li>
<li> 所有权修饰符与常量修饰符不同，它是位置无关的

<ul>
<li><strong>weak NSObject *myObject;和NSObject </strong>weak *myObject;意义是一样的。因为ARC的所有权修饰符是对指针起作用的而不是指向的值。</li>
</ul>
</li>
<li> __bridge

<ul>
<li>普通的转换，它告诉ARC不要增加他的引用计数的值，也不改变所有权</li>
</ul>
</li>
<li> __bridge_retained

<ul>
<li>转换C指针类型并增加引用计数的值</li>
</ul>
</li>
<li> __bridge_transfer

<ul>
<li>将Core Foundation指针类型转换成为Object-C指针并为引用计数加一</li>
</ul>
</li>
<li> 强行忽略警告</li>
</ul>


<p>```objc</p>

<h1>pragma clang diagnostic push</h1>

<h1>pragma clang diagnostic ignored “-Warc-perfprmSelector-leaks”</h1>

<pre><code> [self performSelector:self.mySelector];
</code></pre>

<h1>pragma clang diagnostic pop</h1>

<p>```</p>

<ul>
<li> 避免循环保留</li>
</ul>


<p>```objc
<strong>weak typeof(<em>self) </em>this = self; //iOS 5+
</strong>unsafe_unretained typeof(<em>self) </em>this = self;// iOS 4+</p>

<p>self.myBlock = ^(NSString *returnedString){
this.labelControl.text = returnedString;
}
```</p>

<ul>
<li> CFSTR()从一个制定的字符串中创建一个CFStringRef对象。</li>
<li> @autoreleasepool{}

<ul>
<li>当一段代码加入了大量的autorelease变量时</li>
<li>如果在主线程外使用cocoa调用，例如foundation应用，或者detach一个线程，需要创建自动释放池</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2012/04/23/arc/"/>
    <updated>2012-04-23T02:49:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2012/04/23/arc</id>
    <content type="html"><![CDATA[<h1>工作原理</h1>

<p>自动计数（ARC）是一个编译期间工作的能够帮你管理内存的技术。
ARC在编译期间为每个Objective-C指针变量添加合适的retain, release, autorelease等函数，保存每个变量的生存周期控制在合理的范围内，以期实现代码上的自动内存管理。
In order for the compiler to generate correct code, ARC imposes some restrictions on the methods you can use, and on how you use toll-free bridging (see “Toll-Free Bridged Types”); ARC also introduces new lifetime qualifiers for object references and declared properties.</p>

<h1>功能</h1>

<p>ARC使得你不需要再思考何时使用retain,release,autorelease这样的函数来管理内存，它提供了自动评估内存生存期的功能，并且 在编译期间自动加入合适的管理内存的方法。编译器也会自动生成dealloc函数。</p>

<!--more-->


<h1>新规则</h1>

<ul>
<li><p>不能直接调用dealloc方法，不能重载或直接调用retain, release, retainCount,或 autorelease等方法。但可以通过@selector(retain), @selector(release)这样的形式调用。</p></li>
<li><p>用户自定义的dealloc方法，不能调用[super dealloc] ，编译器会自动帮你添加这个代码。</p></li>
<li><p>对Core Foundation-style 的对象，仍可以使用CFRetain, CFRelease等方法。</p></li>
<li><p>不能使用NSAllocateObject或NSDeallocateObject去创建对象，请使用alloc方法。</p></li>
<li><p>在c语言中的结构体中，不能再使用对象指针。请放弃C结构体，使用Objective-C的类。</p></li>
<li><p>id和void*之间没有隐式的类型转换，请使用显式类型转换。</p></li>
<li><p>不能使用NSAutoreleasePool *pool= ARC提供了@autoreleasepool语句块。</p></li>
</ul>


<h1>关于对象的生命周期</h1>

<p>设置成weak的属性，不会影响对象的生命周期，如果引用的对象已经被释放，引用会指向nil。 strong引用：设置成strong的属性，会影响对象的生命周期。</p>

<p>例如：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(strong) MyClass *myObject;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>和</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(retain) MyClass *myObject;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>是等效的。</p>

<p>又例如：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(weak) MyClass *myObject;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>和</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(assign) MyClass *myObject;</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在多数情况下等效，但当instance被释放时，设置为weak的引用会指向nil。
可用的限定词： strong， 默认的 weak <strong>unsafe_unretained，和weak的区别是当对象被释放时，引用不指向nil。 </strong>autoreleasing，当方法的参数是id*，且希望方法返回时对象被autoreleased，可以添加<strong>autoreleasing限定词。 使用</strong>weak时要特别小心，如果weak引用的对象在此次使用之前被使用过一次，那么它一直存在，直到autoreleasepool释放它，否则就是nil。</p>

<p>例如</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString __weak *string = [[NSString alloc] initWithFormat:@&ldquo;First Name: %@&rdquo;, [self firstName]];   
</span><span class='line'>string = NSLog(@&ldquo;string: %@&rdquo;, string); //此时string为空，因为weak类型不影响对象的生命周期，对象刚创建就释放了。</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其他特性： 使用strong, weak, autoreleasing限定的变量会被隐式初始化为nil。</p>

<p>例如：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)myMethod { NSString *name; NSLog(@&ldquo;name: %@&rdquo;, name); //会输出null }</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>weak与assign很像,不同在于如果指向的数据被释放了,那么这个指向nil
unsafe_unretained
相当于assign,指向的数据如果被释放,这个指向原来的地址。</p>

<h1>禁用在Xcode中的特定文件的ARC</h1>

<p>选择项目->Build Phases->Compile Sources,，给需要禁止arc的文件添加 “-fno-objc-arc”（双击该文件）编译标志(Compiler Flags)。</p>

<p>如下图</p>

<p style="text-align: center;"><a href="http://www.flickr.com/photos/mosquitoliu/6956821194/" title="Flickr 上 freefishdss 的 noarc"><img src="http://farm9.staticflickr.com/8013/6956821194_ae58ab56c6.jpg" width="500" height="117" alt="noarc"></a></p>


<h1>注意事项</h1>

<ol>
<li>不可以使用retain,retainCount,release,autorelease 用@select()这样的调用也不行.属性命名不能以new开头。</li>
<li><p>若重写一个类子类的dealloc,不应调用[super dealloc],当然也不用写什么release释放一些什么对象,只是处理一些你觉得必要处理的事情吧,比如中止一个还没有完成的网络请求.</p></li>
<li><p>不能使用NSAllocateObject和NSDeallocateObject</p></li>
<li><p>你不能在c结构中使用对象,更好的方式是使用Objective-c类来代替.</p></li>
<li><p>在id和void*之间不能隐士转换，必须指明相应转换的生命周期。</p></li>
<li><p>不能使用NSAutoreleasePool对象，ARC使用@autoreleasepool{}块代替。</p></li>
</ol>


<h1>Core Foundation 对象与Objective-c对象之间的赋值,函数调用参数相互转化时需要用到的关键字</h1>

<p>__bridge</p>

<p>简单赋值,不会影响两边对象的retain count.</p>

<p>__bridge_transfer</p>

<p>赋值后释放右边的对象</p>

<p>__bridge_retained</p>

<p>赋值后也保留不释放右边的对象</p>

<p>举例:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&ndash;(void)test&lt;br/>
</span><span class='line'>{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>CFStringRef coreFoundationString = CFStringCreateWithCString(CFAllocatorGetDefault(),"C String", kCFStringEncodingUTF8);    // 创建 retainCount = 1
</span><span class='line'>id unknownObjectType = (__bridge id)coreFoundationString; // 简单赋值,不变,retainCount = 1
</span><span class='line'>CFStringRef anotherString = (__bridge_retained CFStringRef)unknownObjectType; // 保留赋值,加一,retainCount = 2
</span><span class='line'>NSString *objCString = (__bridge_transfer NSString *)coreFoundationString; // 释放赋值,减一,retainCount =1;由于NSString*默认strong,加一,retainCount = 2
</span><span class='line'>NSLog(@"String = %@", objCString);
</span><span class='line'>objCString = nil;   // 不再指向原内存,原内存减一,retainCount = 1
</span><span class='line'>CFRelease(anotherString);   // 释放,减一,retainCount = 0
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在c型的结构中使用objective-c对象</p>

<p>使用void*代替id;或者使用__unsage_unretained 修饰objective-c对象</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存管理]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2012/04/16/nei-cun-guan-li/"/>
    <updated>2012-04-16T15:58:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2012/04/16/nei-cun-guan-li</id>
    <content type="html"><![CDATA[<p>Objective-C使用了一种叫做持有计数（Retain Count）的机制来管理内存中的对象。
在Objective-C中每个对象都对应着他们自己的持有计数（Retain Count），持有计数可以理解为一个整数计数器，当使用alloc方法创建对象的时候，持有计数会自动设置为1。当你向一个对象发送retain消息时，持有计数数值会增加。相反，当你像一个对象发送release消息时，持有计数数值会减小。当对象的持有计数变为0的时候，对象会释放自己所占用的内存。</p>

<!--more-->


<h1>一、引用计数是实例对象的内存回收唯一参考</h1>

<p>引用计数(retainCount)是Objective-C管理对象引用的唯一依据。调用实例的release方法后，此属性减一，减到为零时对象的dealloc方法被自动调用，进行内存回收操作，也就是说我们永不该手动调用对象的dealloc方法。</p>

<p>下面就是它主要操作接口：</p>

<ol>
<li><p>alloc, allocWithZone,new(带初始化)</p>

<p> 为对象分配内存，retainCount为“1”，并返回此实例</p></li>
<li><p>release</p>

<p> retainCount 减“1”，减到“0”时调用此对象的dealloc方法</p></li>
<li><p>retain</p>

<p> ratianCoutn 加“1”</p></li>
<li><p>copy、mutableCopy</p>

<p> 复制一个实例，retainCount数为“1”，返回此实例。所得到的对象是与其它上下文无关的，独立的对象</p></li>
<li><p>autorelease</p>

<p> 在当前上下文的AutoreleasePool栈顶的autoreleasePool实例添加此对象，由于它的引入使Objective-C由全手动内存管理上升到半自动化。</p></li>
</ol>


<h1>二、Object-C内存管理准则</h1>

<p>我们可以把上面的接口按对retainCount的操作性质归为两类</p>

<p>Ａ类是加一操作：1，3，4
Ｂ类是减一操作：2，5（延时释放）内存管理准则如下：
1. A与Ｂ类的调用次数保持一制
2. 为了很好的保障准则一，以实例对象为单位，谁A了就谁Ｂ，没有第二者参与例：</p>

<pre><code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
    NSObject *o = [[NSObject alloc] init];    //retainCount为1
    /[o retain];    //retainCount为2
    //[o release]; //retainCount为1
    //[o autorelease]; //retainCount为1
    [pool release]; //retaincount为0，触发dealloc方法 
</code></pre>

<h1>三、AutoreleasePool使Objective-C成为内存管理半自动化语言</h1>

<p>程序入口</p>

<pre><code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
    int retVal = UIApplicationMain(argc, argv, nil, nil);
    [pool release];
</code></pre>

<p>在 声明pool后，release它之前的这段代码，所有段里的代码（先假设中间没有声明其它的AutoreleasePool实例），凡是调用了 autorelase方法的实例，都会把它的retainCount加1，并在此pool实例中添1次此实例要回收的记录以做备案。当此pool实例 dealloc时，首先会检查之前备案的所有实例，所有记录在案的实例都会依次调用它的release方法。</p>

<pre><code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
    NSObject *o = [[NSObject alloc] init];
    [o autorelease];                                //在pool实例dealloc时，release     一次此实例，重要的是并不是在此行去release
    NSLog(@"o retainCount:%d",[o retainCount]);    //此时还可以看到我们的o实例还是可用的，并且retainCount为1
    [pool release];    //pool 的 retainCount为0，自动调用其dealloc方法，我们之前备案的小o也将在这里release一次（因为咱们之前仅仅autorelease一次）
</code></pre>

<p>真对同一个实例，同一个Pool是可以多次注册备案(autorelease)的。在一些很少的情况化可能会出现这种需求：</p>

<pre><code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
    NSObject *o = [[NSObject alloc] init];
    [o retain];
    [o autorelease];
    [o autorelease];
    [pool release];
</code></pre>

<p>我 们调用了两次A类(retainCount加1的方法)，使其retainCount为2，而接下来的两次autorelease方法调用，使其在 pool中注册备案了两次。这里的pool将会在回收时调用此实例的两次release方法。使其retainCount降为0，完成回收内存的操作，其 实这也是完全按照内存管理规则办事的好处.</p>

<p>AutoreleasePool是被嵌套的！池是被嵌套的，嵌套的结果是个栈，同一线程只有当前栈顶pool实例是可用的：</p>

<p>|  pool_3  |</p>

<p>|  &mdash;&mdash;&mdash;&mdash;-      |</p>

<p>|  pool_2      |</p>

<p>|  &mdash;&mdash;&mdash;&mdash;-   |</p>

<p>|  pool_1  |</p>

<p>|_______|</p>

<pre><code>NSAutoreleasePool *pool1 = [[NSAutoreleasePool alloc] init];
    NSAutoreleasePool *pool2 = [[NSAutoreleasePool alloc] init];
    NSAutoreleasePool *pool3 = [[NSAutoreleasePool alloc] init];

NSObject *o = [[NSObject alloc] init] autorelease];
    [pool3 release];
    [pool2 release];
    [pool1 release];
</code></pre>

<p>我们可以看到其栈顶是pool3，o的autorelease是把当前的release放在栈顶的pool实例管理。。。也就是pool3。
在生命周期短，产生大量放在autoreleasePool中管理实例的情况下经常用此方法减少内存使用，达到内存及时回收的目的。
autorelease pool不是天生的，需要手动创立。只不过在新建一个iphone项目时，xcode会自动帮你写好。autorelease pool的真名是NSAutoreleasePool。</p>

<pre><code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];    NSAutoreleasePool内部包含一个数组（NSMutableArray），用来保存声明为autorelease的所有对象。如果一个对象声明为autorelease，系统所做的工作就是把这个对象加入到这个数组中去。


ClassA *obj1 = [[[ClassA alloc] init] autorelease]; //retain count = 1，把此对象加入autorelease pool中
</code></pre>

<p>NSAutoreleasePool自身在销毁的时候，会遍历一遍这个数组，release数组中的每个成员。如果此时数组中成员的retain count为1，那么release之后，retain count为0，对象正式被销毁。如果此时数组中成员的retain count大于1，那么release之后，retain count大于0，此对象依然没有被销毁，内存泄露。</p>

<p>所有标记为autorelease的对象都只有在这个pool销毁时才被销毁。</p>
]]></content>
  </entry>
  
</feed>
