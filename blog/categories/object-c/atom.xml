<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Object-C | MosquitoLiu's Blog]]></title>
  <link href="http://blog.mosquitoliu.com/blog/categories/object-c/atom.xml" rel="self"/>
  <link href="http://blog.mosquitoliu.com/"/>
  <updated>2014-03-10T12:23:46+08:00</updated>
  <id>http://blog.mosquitoliu.com/</id>
  <author>
    <name><![CDATA[小文]]></name>
    <email><![CDATA[freefishdss@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[延迟操作]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/03/10/delay-operation/"/>
    <updated>2014-03-10T11:15:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/03/10/delay-operation</id>
    <content type="html"><![CDATA[<ul>
<li>performSelector

<ul>
<li>主线程执行，否则无效</li>
<li>非阻塞的执行方法</li>
<li>不能取消执行</li>
</ul>
</li>
</ul>


<p>```objc
[self performSelector:@selector(showNextMessage)</p>

<pre><code>               withObject:nil
               afterDelay:kMinimumMessageVisibleTime];
</code></pre>

<p>```</p>

<ul>
<li>NSTimer 定时器

<ul>
<li>主线程执行，否则无效</li>
<li>非阻塞执行方法</li>
<li>invalidate 可取消执行</li>
</ul>
</li>
</ul>


<p>```objc
 self.cancelSubscriotionTimer = [NSTimer scheduledTimerWithTimeInterval:3</p>

<pre><code>                                                             target:self
                                                           selector:@selector(backIsSubcribe)
                                                           userInfo:nil
                                                            repeats:NO];
</code></pre>

<p> /<em>* 取消 </em>/
  if ([self.cancelSubscriotionTimer isValid]) {</p>

<pre><code>    [self.cancelSubscriotionTimer invalidate];
    self.cancelSubscriotionTimer = nil;
}
</code></pre>

<p>```</p>

<!--more-->


<ul>
<li>GCD方式

<ul>
<li>非阻塞执行方法</li>
<li>github上有取消执行的方法，待测试</li>
</ul>
</li>
</ul>


<p>``` objc
dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 0.3 * NSEC_PER_SEC);</p>

<pre><code>            dispatch_after(time,dispatch_get_main_queue(), ^(void){
                self.subscribeBlock(self);
                [self.activityView stopAnimating];
                self.subscriptionButton.userInteractionEnabled = YES;
            });
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIButton-Image和Title共显]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/03/03/button-displayed-simultaneously-image-and-title/"/>
    <updated>2014-03-03T16:45:22+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/03/03/button-displayed-simultaneously-image-and-title</id>
    <content type="html"><![CDATA[<p>一般情况下设置button的setBackgroundImage，然后setTitle,这样button的image和title都能显示正常。
有时候需要设置button的setImage，在这种情况下再设置setTitle会发现没有共同显示，只是看到image看不到title。其原因是title的位置出现了错误，title的坐标是相对image的坐标。</p>

<p>如：image为下图所示</p>

<iframe src="https://www.flickr.com/photos/mosquitoliu/12905710443/player/30106a7a12" height="48" width="120"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>添加显示title
```objc
……
UIImage *isSubscriptionImage = [UIImage imageWithNameOnly:kIsSubscriptionImageName];</p>

<pre><code>[self.subscriptionButton setTitle:kIsSubscriptionTitleNSString
                         forState:UIControlStateNormal];
[self.subscriptionButton setImage:isSubscriptionImage
                         forState:UIControlStateNormal];
[self.subscriptionButton setTitleColor:RGB(84, 185, 252)                                 
                          forState:UIControlStateNormal];

self.subscriptionButton.contentHorizontalAlignment = UIControlContentHorizontalAlignmentRight;
/** 设置title的坐标 */
[self.subscriptionButton setTitleEdgeInsets:UIEdgeInsetsMake(0, -isSubscriptionImage.size.width - 10, 0, 10)];
……
</code></pre>

<p>```
效果如下所示：</p>

<iframe src="https://www.flickr.com/photos/mosquitoliu/12905989023/player/1d4e627ca6" height="48" width="120"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>




<!--more-->


<p>PS:</p>

<ul>
<li>默认，当按钮高亮的情况下，图像的颜色会被画深一点儿，取消设置如下：</li>
</ul>


<p><code>objc
button.adjustsImageWhenHighlighted = NO;
</code></p>

<ul>
<li>默认，当按钮禁用的时候，图像会被画的深一点儿，取消设置如下:</li>
</ul>


<p><code>objc
button.adjustImageWhenDisabled = NO;
</code></p>

<ul>
<li>按钮按下发光效果，设置如下</li>
</ul>


<p><code>objc
button.showsTouchWhenHighlighted = YES;
</code></p>

<ul>
<li>取消按钮已经添加的所有事件</li>
</ul>


<p>```objc
[button removeTarget:nil</p>

<pre><code>          action:nil
forControlEvents:UIControlEventTouchUpInside];
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UILabel设置text显示不同颜色不同字体]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/03/03/label-different-color-and-font/"/>
    <updated>2014-03-03T14:43:10+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/03/03/label-different-color-and-font</id>
    <content type="html"><![CDATA[<p>```objc</p>

<p>……</p>

<p>UILabel *countLabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 10, 150, 14)];</p>

<p>NSString *text =[NSString stringWithFormat:@&ldquo;共有%d条评论&rdquo;,self.datasource.total];</p>

<p>countLabel.attributedText = [self setCmtHeaderViewLabel:text];</p>

<p>……</p>

<p>/<em><em>
 * 设置label.text中的数字和文字的颜色
 * 数字-RGB(51, 51, 51)
 * 文字-RGB(102, 102, 102)
 </em>/
&ndash; (NSAttributedString </em>)setCmtHeaderViewLabel:(NSString *)text
{</p>

<pre><code>/** 转为可变属性的字符串 */
NSMutableAttributedString *attrText = [[[NSMutableAttributedString alloc] initWithString:text] autorelease];
[attrText addAttribute:(NSString *)NSFontAttributeName
                 value:(id)[[UIFont systemFontOfSize:15] CTFonter]
                 range:NSMakeRange(0, text.length)];
[attrText addAttribute:(NSString *)NSForegroundColorAttributeName
                 value:(id)RGB(102, 102, 102).CGColor
                 range:NSMakeRange(0, text.length)];
[attrText addAttribute:(NSString *)NSForegroundColorAttributeName
                 value:(id)RGB(51, 51, 51).CGColor
                 range:NSMakeRange(2, text.length - 5)];
return attrText;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[instancetype关键字]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/02/09/instancetype-keyword/"/>
    <updated>2014-02-09T11:14:55+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/02/09/instancetype-keyword</id>
    <content type="html"><![CDATA[<p>instancetype关键字，保证了编译器能够正确推断方法的返回的类型。</p>

<p><a href="http://clang.llvm.org/docs/LanguageExtensions.html#objective-c-features">Clang</a>的文档里提到 &ldquo;instancetype is a contextual keyword that is only permitted in the result type of an Object-C method&rdquo; 也就是说,instancetype只能作为返回值，不能像id那样作为参数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC_笔记]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/01/21/arc-note/"/>
    <updated>2014-01-21T17:53:07+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/01/21/arc-note</id>
    <content type="html"><![CDATA[<ul>
<li> dealloc

<ul>
<li>释放一些不在ARC控制下的资源。如Core Foundation对象中调用CFRelease()，对那些通过malloc()分配的内存调用free(),注销通知，停止Timer。</li>
</ul>
</li>
<li> 归零弱引用

<ul>
<li>归零弱引用指针，当他指向的对象被销毁时，系统会自动设置为nil</li>
</ul>
</li>
<li> 混合支持ARC与不支持ARC

<ul>
<li>-fno-objc-arc</li>
<li>-fobjc-arc</li>
</ul>
</li>
<li> 编译时支持ARC而文件的代码不支持ARC</li>
</ul>


<p>```objc</p>

<h1>if !<strong>has</strong>feature(objc_arc)</h1>

<p>//这里是不支持ARC的代码
&ndash; (void)dealloc
{
//在这里释放
}</p>

<h1>endif</h1>

<p>```</p>

<!--more-->


<ul>
<li> 框架中使用ARC代码

<ul>
<li>使用宏提示</li>
</ul>
</li>
</ul>


<p>```objc</p>

<h1>if ! <strong>has</strong>feature(objc_arc)</h1>

<h1>error This file is ARC only</h1>

<h1>endif</h1>

<p>```</p>

<ul>
<li> __unsafe_unretained

<ul>
<li>当你没有指针但想要保存指向某物的引用时，可以是使用__unsafe_unretained</li>
</ul>
</li>
<li> __weak

<ul>
<li>与__unsafe_unretained修饰符非常相似。只是当指针指向的内容被销毁后，弱指针便会成为空值（nil）</li>
<li>仅支持iOS5及以上的系统</li>
<li>声明weak之后，无需在viewDidUnload中将其置为nil</li>
</ul>
</li>
<li> __auto_releasing

<ul>
<li>从方法返回一个自动释放变量时使用</li>
<li>无法用在属性上</li>
</ul>
</li>
<li> 所有权修饰符与常量修饰符不同，它是位置无关的

<ul>
<li><strong>weak NSObject *myObject;和NSObject </strong>weak *myObject;意义是一样的。因为ARC的所有权修饰符是对指针起作用的而不是指向的值。</li>
</ul>
</li>
<li> __bridge

<ul>
<li>普通的转换，它告诉ARC不要增加他的引用计数的值，也不改变所有权</li>
</ul>
</li>
<li> __bridge_retained

<ul>
<li>转换C指针类型并增加引用计数的值</li>
</ul>
</li>
<li> __bridge_transfer

<ul>
<li>将Core Foundation指针类型转换成为Object-C指针并为引用计数加一</li>
</ul>
</li>
<li> 强行忽略警告</li>
</ul>


<p>```objc</p>

<h1>pragma clang diagnostic push</h1>

<h1>pragma clang diagnostic ignored “-Warc-perfprmSelector-leaks”</h1>

<pre><code> [self performSelector:self.mySelector];
</code></pre>

<h1>pragma clang diagnostic pop</h1>

<p>```</p>

<ul>
<li> 避免循环保留</li>
</ul>


<p>```objc
<strong>weak typeof(<em>self) </em>this = self; //iOS 5+
</strong>unsafe_unretained typeof(<em>self) </em>this = self;// iOS 4+</p>

<p>self.myBlock = ^(NSString *returnedString){
this.labelControl.text = returnedString;
}
```</p>

<ul>
<li> CFSTR()从一个制定的字符串中创建一个CFStringRef对象。</li>
<li> @autoreleasepool{}

<ul>
<li>当一段代码加入了大量的autorelease变量时</li>
<li>如果在主线程外使用cocoa调用，例如foundation应用，或者detach一个线程，需要创建自动释放池</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
