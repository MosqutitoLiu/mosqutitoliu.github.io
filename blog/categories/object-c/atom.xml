<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Object-C | MosquitoLiu's Blog]]></title>
  <link href="http://blog.mosquitoliu.com/blog/categories/object-c/atom.xml" rel="self"/>
  <link href="http://blog.mosquitoliu.com/"/>
  <updated>2014-03-11T18:53:46+08:00</updated>
  <id>http://blog.mosquitoliu.com/</id>
  <author>
    <name><![CDATA[小文]]></name>
    <email><![CDATA[freefishdss@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设置菊花（UIActivityIndicatorView）大小]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/03/11/set-uiactivityindicatorview-size/"/>
    <updated>2014-03-11T18:37:10+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/03/11/set-uiactivityindicatorview-size</id>
    <content type="html"><![CDATA[<p>```objc
_activityView = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhite];</p>

<pre><code>     /** 设置中心 */
    _activityView.center = CGPointMake(30, 12);
     /** 设置菊花大小 */
    [_activityView.layer setValue:[NSNumber numberWithFloat:0.6f]
                       forKeyPath:@"transform.scale"];
    /** 当旋转结束时隐藏 */
    [_activityView setHidesWhenStopped:YES];
    _activityView.userInteractionEnabled = NO;
    _activityView.hidden = YES;
    [_subscriptionButton addSubview:_activityView];
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Key-Value-Observing]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/03/11/key-value-observing/"/>
    <updated>2014-03-11T15:59:28+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/03/11/key-value-observing</id>
    <content type="html"><![CDATA[<p>Key-Value-Observing（简称KVO）：当指定的属性被修改，允许对象接受到通知的机制。每次指定的被观察对象的属性被修改的时候，KVO都会自动的去通知相应的观察者。</p>

<ul>
<li><p>优点</p>

<ul>
<li>当有属性改变时，KVO会提供自动的消息通知。不需要设计自己的观察者模型</li>
<li>支持多个观察者观察同一个属性</li>
</ul>
</li>
<li><p>使用</p>

<ul>
<li>是否有必要实现KVO</li>
<li>注册成为观察者</li>
<li>实现addObserver:forKeyPath:option:context:方法</li>
</ul>
</li>
</ul>


<p>```objc</p>

<pre><code>    [self addObserver:observer
           forKeyPath:@"edit"
              options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld
              context:NULL];     
</code></pre>

<p>```</p>

<ul>
<li><ul>
<li><ul>
<li>self : 被观察者</li>
<li>observer ：观察者</li>
<li>foreKeyPath ：property的name</li>
<li>NSKeyValueObservingOptionNew 更改之前的值提供给处理方法；NSKeyValueObservingOptionOld 更改之后的值提供给处理方法；NSKeyValueObservingOptionInitial 把初始化的值提供给处理方法，一旦注册就会调用一次；NSKeyValueObservingOptionPrior 分两次调用，在值改变之前和改变之后</li>
<li>context ：可以带一些参数</li>
</ul>
</li>
<li>当观察者的属性变化的时候方法observeValueForKeyPath:ofObject:change:context:会自动调用</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[延迟操作]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/03/10/delay-operation/"/>
    <updated>2014-03-10T11:15:00+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/03/10/delay-operation</id>
    <content type="html"><![CDATA[<ul>
<li>performSelector

<ul>
<li>主线程执行，否则无效</li>
<li>非阻塞的执行方法</li>
<li>不能取消执行</li>
</ul>
</li>
</ul>


<p>```objc
[self performSelector:@selector(showNextMessage)</p>

<pre><code>               withObject:nil
               afterDelay:kMinimumMessageVisibleTime];
</code></pre>

<p>```</p>

<ul>
<li>NSTimer 定时器

<ul>
<li>主线程执行，否则无效</li>
<li>非阻塞执行方法</li>
<li>invalidate 可取消执行</li>
</ul>
</li>
</ul>


<p>```objc
 self.cancelSubscriotionTimer = [NSTimer scheduledTimerWithTimeInterval:3</p>

<pre><code>                                                             target:self
                                                           selector:@selector(backIsSubcribe)
                                                           userInfo:nil
                                                            repeats:NO];
</code></pre>

<p> /<em>* 取消 </em>/
  if ([self.cancelSubscriotionTimer isValid]) {</p>

<pre><code>    [self.cancelSubscriotionTimer invalidate];
    self.cancelSubscriotionTimer = nil;
}
</code></pre>

<p>```</p>

<!--more-->


<ul>
<li>GCD方式

<ul>
<li>非阻塞执行方法</li>
<li>github上有取消执行的方法，待测试</li>
</ul>
</li>
</ul>


<p>``` objc
dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 0.3 * NSEC_PER_SEC);</p>

<pre><code>            dispatch_after(time,dispatch_get_main_queue(), ^(void){
                self.subscribeBlock(self);
                [self.activityView stopAnimating];
                self.subscriptionButton.userInteractionEnabled = YES;
            });
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIButton-Image和Title共显]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/03/03/button-displayed-simultaneously-image-and-title/"/>
    <updated>2014-03-03T16:45:22+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/03/03/button-displayed-simultaneously-image-and-title</id>
    <content type="html"><![CDATA[<p>一般情况下设置button的setBackgroundImage，然后setTitle,这样button的image和title都能显示正常。
有时候需要设置button的setImage，在这种情况下再设置setTitle会发现没有共同显示，只是看到image看不到title。其原因是title的位置出现了错误，title的坐标是相对image的坐标。</p>

<p>如：image为下图所示</p>

<iframe src="https://www.flickr.com/photos/mosquitoliu/12905710443/player/30106a7a12" height="48" width="120"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>


<p>添加显示title
```objc
……
UIImage *isSubscriptionImage = [UIImage imageWithNameOnly:kIsSubscriptionImageName];</p>

<pre><code>[self.subscriptionButton setTitle:kIsSubscriptionTitleNSString
                         forState:UIControlStateNormal];
[self.subscriptionButton setImage:isSubscriptionImage
                         forState:UIControlStateNormal];
[self.subscriptionButton setTitleColor:RGB(84, 185, 252)                                 
                          forState:UIControlStateNormal];

self.subscriptionButton.contentHorizontalAlignment = UIControlContentHorizontalAlignmentRight;
/** 设置title的坐标 */
[self.subscriptionButton setTitleEdgeInsets:UIEdgeInsetsMake(0, -isSubscriptionImage.size.width - 10, 0, 10)];
……
</code></pre>

<p>```
效果如下所示：</p>

<iframe src="https://www.flickr.com/photos/mosquitoliu/12905989023/player/1d4e627ca6" height="48" width="120"  frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>




<!--more-->


<p>PS:</p>

<ul>
<li>默认，当按钮高亮的情况下，图像的颜色会被画深一点儿，取消设置如下：</li>
</ul>


<p><code>objc
button.adjustsImageWhenHighlighted = NO;
</code></p>

<ul>
<li>默认，当按钮禁用的时候，图像会被画的深一点儿，取消设置如下:</li>
</ul>


<p><code>objc
button.adjustImageWhenDisabled = NO;
</code></p>

<ul>
<li>按钮按下发光效果，设置如下</li>
</ul>


<p><code>objc
button.showsTouchWhenHighlighted = YES;
</code></p>

<ul>
<li>取消按钮已经添加的所有事件</li>
</ul>


<p>```objc
[button removeTarget:nil</p>

<pre><code>          action:nil
forControlEvents:UIControlEventTouchUpInside];
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UILabel设置text显示不同颜色不同字体]]></title>
    <link href="http://blog.mosquitoliu.com/blog/2014/03/03/label-different-color-and-font/"/>
    <updated>2014-03-03T14:43:10+08:00</updated>
    <id>http://blog.mosquitoliu.com/blog/2014/03/03/label-different-color-and-font</id>
    <content type="html"><![CDATA[<p>```objc</p>

<p>……</p>

<p>UILabel *countLabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 10, 150, 14)];</p>

<p>NSString *text =[NSString stringWithFormat:@&ldquo;共有%d条评论&rdquo;,self.datasource.total];</p>

<p>countLabel.attributedText = [self setCmtHeaderViewLabel:text];</p>

<p>……</p>

<p>/<em><em>
 * 设置label.text中的数字和文字的颜色
 * 数字-RGB(51, 51, 51)
 * 文字-RGB(102, 102, 102)
 </em>/
&ndash; (NSAttributedString </em>)setCmtHeaderViewLabel:(NSString *)text
{</p>

<pre><code>/** 转为可变属性的字符串 */
NSMutableAttributedString *attrText = [[[NSMutableAttributedString alloc] initWithString:text] autorelease];
[attrText addAttribute:(NSString *)NSFontAttributeName
                 value:(id)[[UIFont systemFontOfSize:15] CTFonter]
                 range:NSMakeRange(0, text.length)];
[attrText addAttribute:(NSString *)NSForegroundColorAttributeName
                 value:(id)RGB(102, 102, 102).CGColor
                 range:NSMakeRange(0, text.length)];
[attrText addAttribute:(NSString *)NSForegroundColorAttributeName
                 value:(id)RGB(51, 51, 51).CGColor
                 range:NSMakeRange(2, text.length - 5)];
return attrText;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
